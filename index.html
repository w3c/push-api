<!DOCTYPE html>
<html lang="en-US">
  <head>
    <title>
      Push API
    </title>
    <meta charset="utf-8">
    <script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove">
    </script>
    <script class="remove">
    // (this is to make tidy happy)
      // See http://www.w3.org/respec/ for ReSpec documentation.
      var respecConfig = {
          specStatus: "ED",
          shortName: "push-api",

//          previousPublishDate: "2013-08-15",
//          previousMaturity: "WD",
          edDraftURI: "https://w3c.github.io/push-api/",

          editors: [
            {
              name: "Peter Beverloo",
              company: "Google",
              companyURL: "https://www.google.com/",
              w3cid: "44819"
            },
            {
              name: "Martin Thomson",
              company: "Mozilla Foundation",
              companyURL: "https://www.mozilla.org/",
              w3cid: "68503"
            },
            {
              name: "Michaël van Ouwerkerk",
              company: "Google",
              companyURL: "https://www.google.com/",
              note: "until 08 November 2016",
              w3cid: "67729"
            },
            {
              name: "Bryan Sullivan",
              company: "AT&T",
              companyURL: "http://www.att.com/",
              note: "until 01 May 2015",
              w3cid: "41539"
            },
            {
              name: "Eduardo Fullea",
              company: "Telefonica",
              companyURL: "http://www.telefonica.com/",
              note: "until 01 May 2015",
              w3cid: "53513"
            }
          ],

          wg: "Web Platform Working Group",
          wgURI: "https://www.w3.org/WebPlatform/WG/",
          license: "w3c-software-doc",
          wgPublicList: "public-webapps",
          subjectPrefix: "[Push API]",

          // This is important for Rec-track documents, do not copy a patent URI
          // from a random document unless you know what you're doing. If in
          // doubt ask your friendly neighbourhood Team Contact.
          wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/83482/status",

          noLegacyStyle: true,

          otherLinks: [
            {
              key: "Participate",
              data: [
                {
                  value: "Mailing list",
                  href: "http://lists.w3.org/Archives/Public/public-webapps/"
                },
                {
                  value: "Browse open issues",
                  href: "https://github.com/w3c/push-api/issues"
                },
                {
                  value: "File a bug",
                  href: "https://github.com/w3c/push-api/issues/new"
                },
              ]
            },
          ],

          localBiblio: {
            "NOTIFICATIONS": {
              title: "Notifications API",
              href: "https://notifications.spec.whatwg.org/",
              authors: [
                "Anne van Kesteren",
              ],
              status: "Living Standard",
              publisher: "WHATWG"
            },
            "WEBPUSH-PROTOCOL": {
              title: "The Web Push Protocol",
              href: "https://tools.ietf.org/html/draft-ietf-webpush-protocol",
              authors: [
                "Martin Thomson",
                "Brian Raymor",
              ],
              status: "Internet-Draft",
              publisher: "IETF"
            },
            "WEBPUSH-ENCRYPTION": {
              title: "Message Encryption for Web Push",
              href: "https://tools.ietf.org/html/draft-ietf-webpush-encryption",
              authors: [
                "Martin Thomson",
              ],
              status: "Internet-Draft",
              publisher: "IETF"
            },
            "WEBPUSH-VAPID": {
              title: "Voluntary Application Server Identification for Web Push",
              href: "https://tools.ietf.org/html/draft-thomson-webpush-vapid",
              authors: [
                "Martin Thomson",
                "Peter Beverloo",
              ],
              status: "Internet-Draft",
              publisher: "IETF"
            },
            "X9.62": {
              title: "Public Key Cryptography for the Financial Services Industry, The Elliptic Curve Digital Signature Algorithm (ECDSA)",
              status: "ANS X9.62–2005",
              publisher: "ANSI"
            }
          }
      };
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
        The <cite>Push API</cite> enables sending of a <a>push message</a> to a <a>webapp</a> via a
        <a>push service</a>. An <a>application server</a> can send a <a>push message</a> at any
        time, even when a <a>webapp</a> or <a>user agent</a> is inactive. The <a>push service</a>
        ensures reliable and efficient delivery to the <a>user agent</a>. <a>Push messages</a> are
        delivered to a <a>Service Worker</a> that runs in the origin of the <a>webapp</a>, which
        can use the information in the message to update local state or display a notification to
        the user.
      </p>
      <p>
        This specification is designed for use with the <a>web push protocol</a>, which describes
        how an <a>application server</a> or <a>user agent</a> interacts with a <a>push service</a>.
      </p>
    </section>
    <section id="sotd"></section>
    <section class="informative" id="introduction">
      <h2>
        Introduction
      </h2>
      <p>
        The Push API allows a <a>webapp</a> to communicate with a <a>user agent</a> asynchronously.
        This allows an <a>application server</a> to provide the <a>user agent</a> with
        time-sensitive information whenever that information becomes known, rather than waiting for
        a user to open the <a>webapp</a>.
      </p>
      <p>
        As defined here, <a>push services</a> support delivery of <a>push messages</a> at any time.
      </p>
      <p>
        In particular, a <a>push message</a> will be delivered to the <a>webapp</a> even if that
        <a>webapp</a> is not currently active in a browser window: this relates to use cases in
        which the user may close the <a>webapp</a>, but still benefits from the <a>webapp</a> being
        able to be restarted when a <a>push message</a> is received. For example, a <a>push
        message</a> might be used to inform the user of an incoming WebRTC call.
      </p>
      <p>
        A <a>push message</a> can also be sent when the <a>user agent</a> is temporarily offline.
        In support of this, the <a>push service</a> stores messages for the <a>user agent</a> until
        the <a>user agent</a> becomes available. This supports use cases where a <a>webapp</a>
        learns of changes that occur while a user is offline and ensures that the <a>user agent</a>
        can be provided with relevant information in a timely fashion. <a>Push messages</a> are
        stored by the <a>push service</a> until the <a>user agent</a> becomes reachable and the
        message can be delivered.
      </p>
      <p>
        The Push API will also ensure reliable delivery of push messages while a <a>user agent</a>
        is actively using a <a>webapp</a>, for instance if a user is actively using the
        <a>webapp</a> or the <a>webapp</a> is in active communication with an <a>application
        server</a> through an active worker, frame, or background window. This is not the primary
        use case for the Push API. A <a>webapp</a> might choose to use the Push API for infrequent
        messages to avoid having to maintain constant communications with the <a>application
        server</a>.
      </p>
      <p>
        Push messaging is best suited to occasions where there is not already an active
        communications channel established between <a>user agent</a> and <a>webapp</a>. Sending
        <a>push messages</a> requires considerably more resources when compared with more direct
        methods of communication such as <a href="https://fetch.spec.whatwg.org/">fetch()</a> or
        <a href="https://html.spec.whatwg.org/multipage/comms.html#network">websockets</a>. <a>Push
        messages</a> usually have higher latency than direct communications and they can also be
        subject to restrictions on use. Most <a>push services</a> limit the size and quantity of
        <a>push messages</a> that can be sent.
      </p>
    </section>
    <section id="conformance">
      <p>
        This specification defines conformance criteria that apply to a single product: the
        <dfn data-lt="agents|user agents">user agent</dfn> that implements the interfaces that
        it contains.
      </p>
      <p>
        Implementations that use ECMAScript to implement the APIs defined in this specification
        MUST implement them in a manner consistent with the ECMAScript Bindings defined in the Web
        IDL specification [[!WEBIDL]].
      </p>
    </section>
    <section>
      <h2>
        Dependencies
      </h2>
      <p>
        The terms <dfn><a href=
        "http://www.w3.org/TR/html51/webappapis.html#current-settings-object">current settings
        object</a></dfn>, <dfn><a href=
        "http://www.w3.org/TR/html51/webappapis.html#event-handlers">event handler</a></dfn>,
        <dfn><a href="http://www.w3.org/TR/html51/webappapis.html#event-handler-event-type">event
        handler event type</a></dfn>, <dfn><a href=
        "http://www.w3.org/TR/html51/webappapis.html#fire-a-simple-event">fire a simple
        event</a></dfn>, <dfn><a href=
        "http://www.w3.org/TR/html51/webappapis.html#queue-a-task">queue a task</a></dfn> and
        <dfn><a href=
        "http://www.w3.org/TR/html51/infrastructure.html#concept-events-trusted">trusted
        event</a></dfn> are defined in [[!HTML51]].
      </p>
      <p>
        <code><a href=
        "https://tc39.github.io/ecma262/#sec-promise-objects"><dfn>Promise</dfn></a></code>, and
        <code><a href=
        "https://tc39.github.io/ecma262/#sec-json.parse"><dfn>JSON.parse</dfn></a></code> are
        defined in [[!ECMASCRIPT]].
      </p>
      <p>
        <code><a href="http://www.w3.org/TR/dom/#eventinit"><dfn>EventInit</dfn></a></code>,
        <code><a href="http://www.w3.org/TR/dom/#domexception"><dfn>DOMException</dfn></a></code>,
        <code><a href="http://www.w3.org/TR/dom/#aborterror"><dfn>AbortError</dfn></a></code>,
        <code><a href=
        "http://www.w3.org/TR/dom/#invalidstateerror"><dfn>InvalidStateError</dfn></a></code>,
        <code><a href=
        "http://www.w3.org/TR/dom/#invalidaccesserror"><dfn>InvalidAccessError</dfn></a></code>,
        <code><a href=
        "http://www.w3.org/TR/dom/#invalidcharactererror"><dfn>InvalidCharacterError</dfn></a></code>,
        <code><a href=
        "http://www.w3.org/TR/dom/#securityerror"><dfn>SecurityError</dfn></a></code>,
        <a href="http://www.w3.org/TR/dom/#concept-event-listener"><dfn>event listener</dfn></a>,
        and <a href="http://www.w3.org/TR/dom/#concept-event-constructor"><dfn>steps for
        constructing events</dfn></a> are defined in [[!DOM]].
      </p>
      <p>
        The terms <a href="http://www.w3.org/TR/service-workers/#dfn-service-worker"><dfn>service
        worker</dfn></a>, <a href=
        "http://www.w3.org/TR/service-workers/#dfn-service-worker-registration"><dfn>service worker
        registration</dfn></a>, <a href=
        "http://www.w3.org/TR/service-workers/#dfn-installing-worker"><dfn>installing
        worker</dfn></a>, <a href=
        "http://www.w3.org/TR/service-workers/#dfn-waiting-worker"><dfn>waiting worker</dfn></a>,
        and <a href="http://www.w3.org/TR/service-workers/#dfn-active-worker"><dfn>active
        worker</dfn></a>, and the types <code><a href=
        "http://www.w3.org/TR/service-workers/#service-worker-registration-interface"><dfn>ServiceWorkerRegistration</dfn></a></code>,
        <code><a href=
        "http://www.w3.org/TR/service-workers/#service-worker-global-scope-interface"><dfn>ServiceWorkerGlobalScope</dfn></a></code>,
        <code><a href=
        "http://www.w3.org/TR/service-workers/#extendable-event-interface"><dfn>ExtendableEvent</dfn></a></code>,
        <code><a href=
        "http://www.w3.org/TR/service-workers/#extendable-event-init-dictionary"><dfn>ExtendableEventInit</dfn></a></code>,
        <a href="http://www.w3.org/TR/service-workers/#dfn-extend-lifetime-promises"><dfn>extend
        lifetime promises</dfn></a>, the <a href=
        "http://www.w3.org/TR/service-workers/#clear-registration-algorithm"><dfn>Clear
        Registration</dfn></a> algorithm, and the <a href=
        "http://www.w3.org/TR/service-workers/#handle-functional-event-algorithm"><dfn>Handle
        Functional Event</dfn></a> algorithm are defined in [[!SERVICE-WORKERS]].
      </p>
      <p>
        The term <a href="https://www.w3.org/TR/secure-contexts/#secure-context"><dfn>secure
        context</dfn></a> is defined in [[!POWERFUL-FEATURES]].
      </p>
      <p>
        The algorithms <a href="http://www.w3.org/TR/encoding/#utf-8-encode"><dfn>utf-8
        encode</dfn></a>, and <a href="http://www.w3.org/TR/encoding/#utf-8-decode"><dfn>utf-8
        decode</dfn></a> are defined in [[!ENCODING]].
      </p>
      <p>
        <code><a href="http://www.w3.org/TR/FileAPI/#blob"><dfn>Blob</dfn></a></code> is defined in
        [[!FILEAPI]].
      </p>
      <p>
        <code><a href="http://www.w3.org/TR/WebIDL/#idl-any"><dfn>Any</dfn></a></code>,
        <code><a href=
        "http://heycam.github.io/webidl/#idl-ArrayBuffer"><dfn>ArrayBuffer</dfn></a></code>,
        <code><a href=
        "http://heycam.github.io/webidl/#common-BufferSource"><dfn>BufferSource</dfn></a></code>,
        <code><a href=
        "https://heycam.github.io/webidl/#idl-DOMString"><dfn>DOMString</dfn></a></code>,
        <code><a href=
        "http://heycam.github.io/webidl/#notallowederror"><dfn>NotAllowedError</dfn></a></code>,
        and <code><a href=
        "http://heycam.github.io/webidl/#idl-USVString"><dfn>USVString</dfn></a></code> are defined
        in [[!WEBIDL]].
      </p>
      <p>
        The <dfn>web push protocol</dfn> [[!WEBPUSH-PROTOCOL]] describes a protocol that enables
        communication between a <a>user agent</a> or <a>application server</a> and a <a>push
        service</a>. Alternative protocols could be used in place of this protocol, but this
        specification assumes the use of this protocol; alternative protocols are expected to
        provide compatible semantics.
      </p>
    </section>
    <section>
      <h2>
        Concepts
      </h2>
      <section>
        <h2>
          Webapp
        </h2>
        <p>
          The term <dfn data-lt="webapps">webapp</dfn> refers to a Web application, i.e. an
          application implemented using Web technologies, and executing within the context of a Web
          <a>user agent</a>, e.g. a Web browser or other Web runtime environment.
        </p>
        <p>
          The term <dfn data-lt="application servers">application server</dfn>
          refers to server-side components of a <a>webapp</a>.
        </p>
      </section>
      <section>
        <h2>
          Push message
        </h2>
        <p>
          A <dfn data-lt="push messages">push message</dfn> is data sent to a
          <a>webapp</a> from an <a>application server</a>.
        </p>
        <p>
          A <a>push message</a> is delivered to the <a>active worker</a> associated with the
          <a>push subscription</a> to which the message was submitted. If the service worker is not
          currently running, the worker is started to enable delivery.
        </p>
      </section>
      <section>
        <h2>
          Push subscription
        </h2>
        <p>
          A <dfn data-lt="push subscriptions">push subscription</dfn> is a
          message delivery context established between the <a>user agent</a> and the <a>push
          service</a> on behalf of a <a>webapp</a>. Each <a>push subscription</a> is associated
          with a <a>service worker registration</a> and a <a>service worker registration</a> has at
          most one <a>push subscription</a>.
        </p>
        <p>
          A <a>push subscription</a> has an associated <dfn data-lt=
          "push endpoints">push endpoint</dfn>. It MUST be the absolute URL exposed
          by the <a>push service</a> where the <a>application server</a> can send <a>push
          messages</a> to. A <a>push endpoint</a> MUST uniquely identify the <a>push
          subscription</a>.
        </p>
        <p>
          A <a>push subscription</a> has internal slots for a P-256 <a>ECDH</a> key pair and an
          authentication secret in accordance with [[!WEBPUSH-ENCRYPTION]]. These slots MUST be
          populated when creating the <a>push subscription</a>.
        </p>
        <p>
          If the <a>user agent</a> has to change the keys for any reason,
          it MUST <a>fire the pushsubscriptionchange event</a> with the
          <a>service worker registration</a> associated with the <a>push subscription</a> as
          <var>registration</var>, a <a>PushSubscription</a> instance representing the
          <a>push subscription</a> having the old keys as <var>oldSubscription</var> and a
          <a>PushSubscription</a> instance representing the <a>push subscription</a> having the new
          keys as <var>newSubscription</var>.
        </p>
        <section>
          <h2>
            Subscription Refreshes
          </h2>
          <p>
            A <a>user agent</a> or <a>push service</a> MAY choose to <dfn>refresh</dfn> a
            <a>push subscription</a> at any time, for example because it has reached a certain age.
          </p>
          <p>
            When this happens, the <a>user agent</a> MUST create a new <a>push subscription</a>
            with the <a>push service</a> on behalf of the application, using the
            <a>PushSubscriptionOptions</a> that were provided for creating the current
            <a>push subscription</a>. The new <a>push subscription</a> MUST have a key pair that's
            different from the original subscription.
          </p>
          <p>
            When successful, <a>user agent</a> then MUST <a>fire the pushsubscriptionchange event</a>
            with the <a>service worker registration</a> associated with the <a>push subscription</a>
            as <var>registration</var>, a <a>PushSubscription</a> instance representing the initial
            <a>push subscription</a> as <var>oldSubscription</var> and a <a>PushSubscription</a>
            instance representing the new <a>push subscription</a> as <var>newSubscription</var>.
          </p>
          <p>
            To allow for time to propagate changes to <a>application servers</a>, a <a>user agent</a>
            MAY continue to accept messages for an old <a>push subscription</a> for a brief time
            after a refresh. Once messages have been received for a refreshed
            <a>push subscription</a>, any old <a>push subscriptions</a> MUST be <a>deactivated</a>.
          </p>
          <p>
            If the <a>user agent</a> is not able to refresh the <a>push subscription</a>, it SHOULD
            periodically retry the refresh. When the <a>push subscription</a> can no longer be used,
            for example because it has expired, the <a>user agent</a> MUST
            <a>fire the pushsubscriptionchange event</a> with the <a>service worker registration</a>
            associated with the <a>push subscription</a> as <var>registration</var>, a
            <a>PushSubscription</a> instance representing the deactivating <a>push subscription</a>
            as <var>oldSubscription</var> and <code>null</code> as the <var>newSubscription</var>.
          </p>
        </section>
        <section>
          <h2>
            Subscription Deactivation
          </h2>
          <p>
            When a <a>push subscription</a> is <dfn data-lt=
            "deactivate">deactivated</dfn>, both the <a>user agent</a> and the <a>push
            service</a> MUST delete any stored copies of its details. Subsequent
            <a>push messages</a> for this <a>push subscription</a> MUST NOT be delivered.
          </p>
          <p>
            A <a>push subscription</a> is <a>deactivated</a> when its associated <a>service worker
            registration</a> is unregistered, though a <a>push subscription</a> MAY be
            <a>deactivated</a> earlier. A <a>push subscription</a> is removed when the <a>clear
            registration</a> algorithm is run for the <a>service worker registration</a>.
          </p>
        </section>
      </section>
      <section>
        <h2>
          Push service
        </h2>
        <p>
          The term <dfn data-lt="push services">push service</dfn> refers to a system
          that allows <a>application servers</a> to send <a>push messages</a> to a <a>webapp</a>. A
          push service serves the <a>push endpoint</a> or <a data-lt="push endpoints">endpoints</a>
          for the <a>push subscriptions</a> it serves.
        </p>
      </section>
      <section>
        <h2>
          Permission
        </h2>
        <p>
          The term <dfn>express permission</dfn> refers to an act by the user, e.g. via user
          interface or host device platform features, via which the user approves the use of the
          Push API by the <a>webapp</a>.
        </p>
      </section>
    </section>
    <section>
      <h2>
        Security and privacy considerations
      </h2>
      <p>
        <a>User agents</a> MUST NOT provide Push API access to <a>webapps</a> without the
        <a>express permission</a> of the user. <a>User agents</a> MUST acquire consent for
        permission through a user interface for each call to the <code>subscribe()</code> method,
        unless a previous permission grant has been persisted, or a prearranged trust relationship
        applies. Permissions that are preserved beyond the current browsing session MUST be
        revocable.
      </p>
      <p>
        The <a>user agent</a> MAY consider the <a>PushSubscriptionOptions</a> when
        acquiring permission or determining the permission status.
      </p>
      <p>
        When a permission is revoked, the <a>user agent</a> MAY
        <a>fire the pushsubscriptionchange event</a> for subscriptions created with that permission,
        with the <a>service worker registration</a> associated with the <a>push subscription</a> as
        <var>registration</var>, a <a>PushSubscription</a> instance representing the
        <a>push subscription</a> as <var>oldSubscription</var>, and <code>null</code> as
        <var>newSubscription</var>. The <a>user agent</a> MUST <a>deactivate</a> the affected
        subscriptions in parallel.
      </p>
      <p>
        When a <a>service worker registration</a> is unregistered, any associated <a>push
        subscription</a> MUST be <a>deactivated</a>.
      </p>
      <p>
        The <a>push endpoint</a> of a <a>deactivated</a> <a>push subscription</a> MUST NOT be
        reused for a new <a>push subscription</a>. This prevents the creation of a persistent
        identifier that the user cannot remove. This also prevents reuse of the details of one
        <a>push subscription</a> to send <a>push messages</a> to another <a>push subscription</a>.
      </p>
      <p>
        <a>User agents</a> MUST implement the Push API to only be available in <a data-lt=
        "secure context">secure contexts</a>. This provides better protection for the user against
        man-in-the-middle attacks intended to obtain push subscription data. Browsers may ignore
        this rule for development purposes only.
      </p>
      <p>
        There is no guarantee that a <a>push message</a> was sent by an <a>application server</a>
        having the same origin as the <a>webapp</a>. The <a>application server</a> is able to
        share the details necessary to to use a <a>push subscription</a> with a third party at its
        own discretion.
      </p>
    </section>
    <section class="informative" id="pushframework">
      <h2>
        Push Framework
      </h2>
      <p>
        A <a>push message</a> is sent from an <a>application server</a> to a <a>webapp</a> as
        follows:
      </p>
      <ul>
        <li>the <a>application server</a> requests that the <a>push service</a> deliver a <a>push
        message</a> using the [[!WEBPUSH-PROTOCOL]]. This request uses the <a>push endpoint</a>
        included in the <a>push subscription</a>;
        </li>
        <li>the <a>push service</a> delivers the message to a specific <a>user agent</a>,
        identifying the <a>push endpoint</a> in the message;
        </li>
        <li>the <a>user agent</a> identifies the intended <a>Service Worker</a> and activates it as
        necessary, and delivers the <a>push message</a> to the <a>Service Worker</a>.
        </li>
      </ul>
      <p>
        This overall framework allows <a>application servers</a> to activate a <a>Service
        Worker</a> in response to events at the <a>application server</a>. Information about those
        events can be included in the <a>push message</a>, which allows the <a>webapp</a> to react
        appropriately to those events, potentially without needing to initiate network requests.
      </p>
      <p>
        The following code and diagram illustrate a hypothetical use of the push API.
      </p>
      <section class="informative">
        <h2>
          Example
        </h2>
        <pre class="example highlight">// https://example.com/serviceworker.js
this.onpush = function(event) {
  console.log(event.data);
  // From here we can write the data to IndexedDB, send it to any open
  // windows, display a notification, etc.
}

// https://example.com/webapp.js
navigator.serviceWorker.register('serviceworker.js').then(
  function(serviceWorkerRegistration) {
    serviceWorkerRegistration.pushManager.subscribe().then(
      function(pushSubscription) {
        console.log(pushSubscription.endpoint);
        console.log(pushSubscription.getKey('p256dh'));
        console.log(pushSubscription.getKey('auth'));
        // The push subscription details needed by the application
        // server are now available, and can be sent to it using,
        // for example, an XMLHttpRequest.
      }, function(error) {
        // During development it often helps to log errors to the
        // console. In a production environment it might make sense to
        // also report information about errors back to the
        // application server.
        console.log(error);
      }
    );
  });
</pre>
      </section>
      <section class="informative">
        <h2>
          Sequence diagram
        </h2>
        <figure>
          <a href="sequence_diagram.png"><img src="sequence_diagram.png" width="795" height="870"
          alt=
          "Example flow of events for subscription, push message delivery, and unsubscription"></a>
          <figcaption>
            Example flow of events for subscription, push message delivery, and unsubscription
          </figcaption>
        </figure>
      </section>
      <section>
        <h3>
          Push service use
        </h3>
        <p>
          The fields included in the <code>PushSubscription</code> is all the information needed
          for an <a>application server</a> to send a <a>push message</a>. Push services that are
          compatible with the Push API provide a <a>push endpoint</a> that conforms to the <a>web
          push protocol</a>. These parameters and attributes include:
        </p>
        <ul>
          <li>The <a data-lt="PushSubscription.endpoint">push endpoint</a> of a <code>
            PushSubscription</code> is a URL that allows an <a>application server</a> to request
            delivery of a <a>push message</a> to a <a>webapp</a>.
          </li>
          <li>The <code><a data-lt="PushSubscription.getKey">getKey</a></code> method on a
          <code>PushSubscription</code> is used to retrieve keying material used to encrypt and
          authenticate <a>push messages</a>. Each invocation of the function returns a new
          <code>ArrayBuffer</code> that contains the value of the corresponding key, or
          <code>null</code> if the identified key doesn't exist. Passing a value of
          <a>p256dh</a> retrieves a <dfn data-lt="ECDH">elliptic curve Diffie-Hellman
          (ECDH)</dfn> public key associated with the <a>push subscription</a>. Passing a value of
          <code>auth</code> returns an authentication secret that an application server uses in
          authentication of its messages. These keys are used by the <a>application server</a> to
          encrypt and authenticate messages for the <a>push subscription</a>, as described in
          [[!WEBPUSH-ENCRYPTION]].
          </li>
        </ul>
      </section>
    </section>
    <section data-dfn-for="ServiceWorkerRegistration">
      <h2>
        Extensions to the <a>ServiceWorkerRegistration</a> Interface
      </h2>
      <p>
        The Service Worker specification defines a <a>ServiceWorkerRegistration</a> interface
        [[!SERVICE-WORKERS]], which this specification extends.
      </p>
      <pre class="idl">
        partial interface ServiceWorkerRegistration {
          readonly attribute PushManager pushManager;
        };
      </pre>
      <p>
        The <dfn>pushManager</dfn>
        attribute exposes a <a>PushManager</a>, which has an associated <a>service
        worker registration</a> represented by the <a>ServiceWorkerRegistration</a> on
        which the attribute is exposed.
      </p>
    </section>
    <section data-dfn-for="PushManager">
      <h2>
        <dfn>PushManager</dfn> interface
      </h2>
      <p>
        The <a>PushManager</a> interface defines the operations to access <a>push services</a>.
      </p>
      <pre class="idl">
        interface PushManager {
          Promise&lt;PushSubscription&gt; subscribe(optional PushSubscriptionOptionsInit options);
          Promise&lt;PushSubscription?&gt; getSubscription();
          Promise&lt;PushPermissionState&gt; permissionState(optional PushSubscriptionOptionsInit options);
        };
      </pre>
      <p>
        The <dfn>subscribe</dfn>
        method when invoked MUST run the following steps:
      </p>
      <ol>
        <li>Let <var>promise</var> be a new <a>Promise</a>.
        </li>
        <li>Return <var>promise</var> and continue the following steps asynchronously.
        </li>
        <li>If the <a>current settings object</a> is not a <a>secure context</a>, reject
        <var>promise</var> with a <a>DOMException</a> whose name is
        "<a>SecurityError</a>" and terminate these steps.
        </li>
        <li>Let <var>allOptions</var> be the value of the <code>options</code> argument, if
        provided, or a <a>PushSubscriptionOptions</a> dictionary with default values.
        </li>
        <li>If <var>allOptions</var> includes a non-null value for the
        <code><a>applicationServerKey</a></code> attribute, run the following substeps:
          <ol>
            <li>Let <var>applicationServerKey</var> be the sequence of octets in
            <code><a>applicationServerKey</a></code> when provided as a <code><a>BufferSource</a></code>,
            or the sequence of octets that results from decoding
            <code><a>applicationServerKey</a></code> using the base64url encoding [[!RFC7515]] when
            provided as a <code><a>DOMString</a></code>. If decoding fails, reject
            <var>promise</var> with a <code><a>DOMException</a></code> whose name is
            "<code><a>InvalidCharacterError</a></code>" and terminate these steps.
            </li>
            <li>Ensure that <var>applicationServerKey</var> describes a valid point on the P-256
            curve. If the <var>applicationServerKey</var> value is invalid, reject <var>promise</var>
            with a <code><a>DOMException</a></code> whose name is
            "<code><a>InvalidAccessError</a></code>" and terminate these steps.
            </li>
          </ol>
        </li>
        <li>Let <var>registration</var> be the <a>PushManager</a>'s associated
        <a>service worker registration</a>.
        </li>
        <li>If <var>registration</var>'s <a>active worker</a> is null, reject <var>promise</var>
        with a <code><a>DOMException</a></code> whose name is
        "<code><a>InvalidStateError</a></code>" and terminate these steps.</li>
        <li>Ask the user whether they allow the <a>webapp</a> to receive <a>push messages</a>,
        unless a prearranged trust relationship applies or the user has already granted or denied
        permission explicitly for this <a>webapp</a>.
        </li>
        <li>If not granted, reject <var>promise</var> with a <a>DOMException</a> whose
        name is "<a>NotAllowedError</a>" and terminate these steps.
        </li>
        <li>If the <a>Service Worker</a> is already subscribed, run the following substeps:
          <ol>
            <li>Retrieve the <a>push subscription</a> associated with the <a>Service Worker</a>.
            </li>
            <li>If there is an error, reject <var>promise</var> with a
            <a>DOMException</a> whose name is "<a>AbortError</a>" and
            terminate these steps.
            </li>
            <li>Let <var>subscription</var> be the retrieved subscription.
            </li>
            <li>Compare <var>allOptions</var> with the <code>options</code> attribute of
            <var>subscription</var>. If any attribute on <var>allOptions</var> contains a different
            value to that stored for <var>subscription</var>, then reject <var>promise</var> with
            an <a>InvalidStateError</a> and terminate these steps. The contents of
            <a>BufferSource</a> values are compared for equality rather than
              <a href="https://tc39.github.io/ecma262/#sec-reference-specification-type">references</a>.
            </li>
            <li>When the request has been completed, resolve <var>promise</var> with
            <var>subscription</var>.
            </li>
          </ol>
        </li>
        <li>Make a request to the push service to create a new <a>push subscription</a> for the <a>
        Service Worker</a>.
        </li>
        <li>If there is an error, reject <var>promise</var> with a <a>DOMException</a>
        whose name is "<a>AbortError</a>" and terminate these steps.
        </li>
        <li>Let <var>subscription</var> be a new subscription.
        </li>
        <li>Set the <code>options</code> attribute of <var>subscription</var> to be a copy of <var>
          allOptions</var>.
        </li>
        <li>Generate a new P-256 <a>ECDH</a> key pair. Store the private key in an internal slot on
        <var>subscription</var>; this value MUST NOT be made available to applications. The public
        key is also stored in an internal slot and can be retrieved by calling the
        <code>getKey</code> method of the <a>PushSubscription</a> with an argument of
        <a>p256dh</a>.
        </li>
        <li>Generate a new authentication secret, which is a sequence of octets as defined in
        [[!WEBPUSH-ENCRYPTION]]. Store the authentication secret in an internal slot on
        <var>subscription</var>. This key can be retrieved by calling the <code>getKey</code>
        method of the <a>PushSubscription</a> with an argument of
        <a>auth</a>.
        </li>
        <li>When the request has been completed, resolve <var>promise</var> with a
        <a>PushSubscription</a> providing the details of the new <a>push
        subscription</a>.
        </li>
      </ol>
      <p>
        The <dfn>getSubscription</dfn>
        method when invoked MUST run the following steps:
      </p>
      <ol>
        <li>Let <var>promise</var> be a new <a>Promise</a>.
        </li>
        <li>Return <var>promise</var> and continue the following steps asynchronously.
        </li>
        <li>If the <a>Service Worker</a> is not subscribed, resolve <var>promise</var> with null.
        </li>
        <li>Retrieve the <a>push subscription</a> associated with the <a>Service Worker</a>.
        </li>
        <li>If there is an error, reject <var>promise</var> with a <a>DOMException</a>
        whose name is "<a>AbortError</a>" and terminate these steps.
        </li>
        <li>When the request has been completed, resolve <var>promise</var> with a
        <a>PushSubscription</a> providing the details of the retrieved <a>push
        subscription</a>.
        </li>
      </ol>
      <p>
        The <dfn>
        permissionState</dfn> method when invoked MUST run the following steps:
      </p>
      <ol>
        <li>Let <var>promise</var> be a new <a>Promise</a>.
        </li>
        <li>Return <var>promise</var> and continue the following steps asynchronously.
        </li>
        <li>Retrieve the push permission status (<a>PushPermissionState</a>) of the
        requesting <a>webapp</a>.
        </li>
        <li>If there is an error, reject <var>promise</var> with no arguments and terminate these
        steps.
        </li>
        <li>When the request has been completed, resolve <var>promise</var> with
        <a>PushPermissionState</a> providing the push permission status.
        </li>
      </ol>
      <p>
        Permission to use the push service can be persistent, that is, it does not need to be
        reconfirmed for subsequent subscriptions if a valid permission exists.
      </p>
      <p>
        If there is a need to ask for permission, it needs to be done by invoking the
        <a data-lt="PushManager.subscribe">subscribe</a> method.
      </p>
      <section data-dfn-for="PushSubscriptionOptions">
        <h2>
          <dfn>PushSubscriptionOptions</dfn> Interface and Dictionary
        </h2>
        <p>
          A <a>PushSubscriptionOptionsInit</a> represents additional options associated with a
          <a>push subscription</a>. The <a>user agent</a> MAY consider these options when
          requesting <a>express permission</a> from the user. When an option is considered, the
          <a>user agent</a> SHOULD enforce it on incoming <a>push messages</a>.
        </p>
        <p>
          These options are optional, and <a>user agents</a> MAY choose to support only a subset of
          them. A <a>user agent</a> MUST NOT expose options that it does not support.
        </p>
        <p>
          Once set, options for a <a>push subscription</a> cannot change. A pre-existing <a>push
          subscription</a> can be <a href=
          "#widl-PushSubscription-unsubscribe-Promise-boolean">unsubscribed</a> to create a <a>push
          subscription</a> with new options.
        </p>
        <pre class="idl">
          dictionary PushSubscriptionOptionsInit {
            boolean userVisibleOnly = false;
            (BufferSource or DOMString)? applicationServerKey = null;
          };

          interface PushSubscriptionOptions {
            readonly attribute boolean userVisibleOnly;
            [SameObject] readonly attribute ArrayBuffer? applicationServerKey;
          };
        </pre>
        <p>
          The <dfn>userVisibleOnly</dfn> option,
          when set to <code>true</code>, indicates that the <a>push subscription</a> will only be
          used for <a>push messages</a> whose effect is made visible to the user, for example by
          displaying a Web Notification. [[NOTIFICATIONS]]
        </p>
        <p>
          The <dfn>applicationServerKey</dfn>
          option includes an elliptic curve public key for an application server. This is the key
          that the application server will use to authenticate itself when sending push messages to
          this subscription as defined in [[!WEBPUSH-VAPID]]; the push service will reject any push
          message unless the corresponding private key is used to generate an authentication token.
        </p>
        <p>
          If present, the value of <a>applicationServerKey</a> MUST include a point on
          the P-256 elliptic curve [[!DSS]], encoded in the uncompressed form described in
          [[!X9.62]] Annex A (that is, 65 octets, starting with an 0x04 octet). This value MUST be
          encoded using the base64url encoding [[!RFC7515]] when provided as a
          <code><a>DOMString</a></code>.
        </p>
        <p>
          The <code><a>applicationServerKey</a></code> MUST be a different value to the one used for
          message encryption [[WEBPUSH-ENCRYPTION]].
        </p>
      </section>
    </section>
    <section data-dfn-for="PushSubscription">
      <h2>
        <dfn>PushSubscription</dfn> interface
      </h2>
      <p>
        A <a>PushSubscription</a> object represents a <a>push subscription</a>.
      </p>
      <pre class="idl">
        interface PushSubscription {
          readonly attribute USVString endpoint;
          [SameObject] readonly attribute PushSubscriptionOptions options;
          ArrayBuffer? getKey(PushEncryptionKeyName name);
          Promise&lt;boolean&gt; unsubscribe();
          serializer;
        };
      </pre>
      <p>
        When getting the <dfn>endpoint</dfn>
        attribute, the <a>user agent</a> MUST return the <a>push endpoint</a> associated with the
        <a>push subscription</a>.
      </p>
      <p>
        The <dfn>getKey</dfn> method retrieves keying material that
        can be used for encrypting and authenticating messages. When <a data-lt="PushSubscription.getKey">getKey</a> is
        invoked the following process is followed:
      </p>
      <ol>
        <li>Find the internal slot corresponding to the key named by the <code>name</code>
        argument.
        </li>
        <li>If a slot was not found, return <code>null</code>.
        </li>
        <li>Initialize a variable <var>key</var> with a newly instantiated <code>ArrayBuffer</code>
        instance.
        </li>
        <li>If the internal slot contains an asymmetric key pair, set the contents of
        <var>key</var> to the serialized value of the public key from the key pair. This uses the
        serialization format described in the specification that defines the name. For example,
        [[!WEBPUSH-ENCRYPTION]] specifies that the <a>p256dh</a> public key is encoded
        using the uncompressed format defined in [[X9.62]] Annex A (that is, a 65 octet sequence
        that starts with a 0x04 octet).
        </li>
        <li>Otherwise, if the internal slot contains a symmetric key, set the contents of
        <var>key</var> to a copy of the value from the internal slot. For example, the
        <code>auth</code> parameter contains an octet sequence used by the <a>user agent</a> to
        authenticate messages sent by an <a>application server</a>.
        </li>
        <li>Return <var>key</var>.
        </li>
      </ol>
      <p>
        Keys named <a>p256dh</a> and <a>auth</a> MUST be supported, and
        their values MUST correspond to those necessary for the user agent to decrypt received push
        messages in accordance with [[!WEBPUSH-ENCRYPTION]].
      </p>
      <p>
        The <dfn>unsubscribe</dfn> method when
        invoked MUST run the following steps:
      </p>
      <ol>
        <li>Let <var>promise</var> be a new <a>Promise</a>.
        </li>
        <li>Return <var>promise</var> and continue the following steps asynchronously.
        </li>
        <li>If the <a>push subscription</a> has already been <a>deactivated</a>, resolve
        <var>promise</var> with <code>false</code> and terminate these steps.
        </li>
        <li>Run the following step in parallel:
          <ol>
            <li><a>Deactivate</a> the <a>push subscription</a>. The <a>user agent</a> MUST NOT
            deliver any further <a>push messages</a> for the <a>push subscription</a>.
            <p>If the <a>user agent</a> failed to request the <a>push service</a> to <a>deactivate</a>
            the <a>push subscription</a>, for example because of network failures, it SHOULD retry
            the request to the <a>push service</a> for a reasonable amount of time.
            </li>
          </ol>
        </li>
        <li>Resolve <var>promise</var> with <code>true</code>.
        </li>
      </ol>
      <p>
        The serializer for a <a>PushSubscription</a> invokes the following steps:
      </p>
      <ol>
        <li>Let <var>map</var> be an empty map.
        </li>
        <li>Add an entry to <var>map</var> whose key name is <code>endpoint</code> and whose value
        is the result of converting the <code>endpoint</code> attribute of the
        <a>PushSubscription</a> to a serialized value. The <a>user agent</a> MUST use
        a serialization method that does not contain input-dependent branchs (that is, one that is
        constant time). Note that a URL - as ASCII text - will not ordinarily require special
        treatment.
        </li>
        <li>Let <var>keys</var> be an empty map.
        </li>
        <li>For each identifier <var>i</var> corresponding to keys in internal slots on the
        <a>PushSubscription</a>, ordered by the name of the key:
          <ol>
            <li>If the internal slot corresponds to an asymmetric key pair, let <var>b</var> be the
            encoded value of the public key corresponding to the key name <var>i</var>, using the
            encoding defined for the key name (see <a data-lt="PushSubscription.getKey">getKey</a>).
            </li>
            <li>Otherwise, let <var>b</var> be the value as returned by <a data-lt="PushSubscription.getKey">getKey</a>.
            </li>
            <li>Let <var>s</var> be the URL-safe base64 encoding without padding [[!RFC4648]] of
            <var>b</var> as a <a>USVString</a>. The <a>user agent</a> MUST use a
            serialization method that does not branch based on the value of <var>b</var>.
            </li>
            <li>Add an entry to <var>keys</var> whose key name is the name of <var>i</var> and
            whose value is <var>s</var>.
            </li>
          </ol>
        </li>
        <li>Add an entry to <var>map</var> whose key name is <code>keys</code> and whose value is
        <var>keys</var>.
        </li>
        <li>Return <var>map</var>.
        </li>
      </ol>
      <p>
        Note that the options to a <a>PushSubscription</a> are not serialized.
      </p>
      <section>
        <h2>
          <dfn>PushEncryptionKeyName</dfn> enumeration
        </h2>
        <p>
          Encryption keys used for <a>push message</a> encryption are provided to a <a>webapp</a>
          through the <a data-lt="PushSubscription.getKey">getKey</a> method or the serializer of
          <a>PushSubscription</a>. Each key is named using a value from the
          <a>PushEncryptionKeyName</a> enumeration.
        </p>
        <pre class="idl">
          enum PushEncryptionKeyName {
            "p256dh",
            "auth"
          };
        </pre>
        <p>
          The <dfn>p256dh</dfn> value is
          used to retrieve the P-256 ECDH Diffie-Hellman public key described in
          [[!WEBPUSH-ENCRYPTION]].
        </p>
        <p>
          The <dfn>auth</dfn> value is used to
          retrieve the authentication secret described in [[!WEBPUSH-ENCRYPTION]].
        </p>
      </section>
    </section>
    <section data-dfn-for="PushMessageData">
      <h2>
        <dfn>PushMessageData</dfn> interface
      </h2>
      <pre class="idl">
        [Exposed=ServiceWorker]
        interface PushMessageData {
          ArrayBuffer arrayBuffer();
          Blob blob();
          any json();
          USVString text();
        };
      </pre>
      <p>
        <a>PushMessageData</a> objects have an associated <dfn>bytes</dfn> (a byte sequence) set on
        creation, which is <code>null</code> if there was no data in the <a>push message</a>.
      </p>
      <p>
        The <dfn>arrayBuffer</dfn>
        method, when invoked, MUST return an <a>ArrayBuffer</a> whose contents are
        <var>bytes</var>. Exceptions thrown during the creation of the
        <a>ArrayBuffer</a> object are re-thrown.
      </p>
      <p>
        The <dfn>blob</dfn> method, when
        invoked, MUST return a <a>Blob</a> whose contents are <var>bytes</var> and
        <var>type</var> is not provided.
      </p>
      <p>
        The <dfn>json</dfn> method, when
        invoked, MUST return the result of invoking the initial value of
        <a>JSON.parse</a> with the result of running <a>utf-8 decode</a> on
        <var>bytes</var> as argument. Re-throw any exceptions thrown by
        <a>JSON.parse</a>.
      </p>
      <p>
        The <dfn>text</dfn> method, when
        invoked, MUST return the result of running <a>utf-8 decode</a> on <var>bytes</var>.
      </p>
      <p>
        To <dfn>extract a byte sequence</dfn> from <var>object</var>, run these steps:
      </p>
      <ol>
        <li>Let <var>bytes</var> be an empty byte sequence.
        </li>
        <li>Switch on <var>object</var>'s type:
          <dl>
            <dt>
              <a>BufferSource</a>
            </dt>
            <dd>
              Set <var>bytes</var> to a copy of <var>object</var>'s contents.
            </dd>
            <dt>
              <a>USVString</a>
            </dt>
            <dd>
              Set <var>bytes</var> to the result of running <a>utf-8 encode</a> on
              <var>object</var>.
            </dd>
          </dl>
        </li>
        <li>Return <var>bytes</var>.
        </li>
      </ol>
    </section>
    <section>
      <h2>
        Events
      </h2>
      <section data-dfn-for="ServiceWorkerGlobalScope">
        <h2>Extensions to the <a>ServiceWorkerGlobalScope</a> interface</h2>
        <p>
          The Service Worker specification defines a <code>ServiceWorkerGlobalScope</code> interface
          [[!SERVICE-WORKERS]], which this specification extends.
        </p>
        <pre class="idl">
          partial interface ServiceWorkerGlobalScope {
            attribute EventHandler onpush;
            attribute EventHandler onpushsubscriptionchange;
          };
        </pre>
        <p>
          The <dfn>onpush</dfn> attribute is
          an <a>event handler</a> whose corresponding <a>event handler event type</a> is
          <code>push</code>.
        </p>
        <p>
          The <dfn>onpushsubscriptionchange</dfn>
          attribute is an <a>event handler</a> whose corresponding <a>event handler event type</a> is
          <code>pushsubscriptionchange</code>.
        </p>
      </section>
      <section>
        <h2>
          The <dfn>push</dfn> Event
        </h2>
        <p>
          The <a>push</a> event indicates that a <a>push message</a> has been received for a
          <a>push subscription</a>.
        </p>
        <p>
          To <dfn>fire the push event</dfn> given a <a>service worker registration</a> of
          <var>registration</var> and a <code>PushMessageData</code> of <var>data</var>, the
          <a>user agent</a> must run the following steps:
        </p>
        <ol>
          <li>Create a <a>trusted event</a>, <var>event</var>, that uses the
          <a>PushEvent</a> interface, with the event type <code>pushevent</code>, which does not
          bubble, is not cancelable, and has no default action.
          </li>
          <li>Set the <code>data</code> attribute of <var>event</var> to <var>data</var>.
          </li>
          <li>Invoke the <a>Handle Functional Event</a> algorithm with <var>event</var> and
          <var>registration</var>, and <var>callbackSteps</var> set to the following steps:
            <ol>
              <li>Set <var>global</var> to the global object associated with the
              <var>registration</var>.
              </li>
              <li>Dispatch <var>event</var> to <var>global</var>.
              </li>
            </ol>
          </li>
          <li>Return <var>event</var>.
          </li>
        </ol>
        <section data-dfn-for="PushEvent">
          <h2>
            <dfn>PushEvent</dfn> Interface
          </h2>
          <pre class="idl">
            typedef (BufferSource or USVString) PushMessageDataInit;

            dictionary PushEventInit : ExtendableEventInit {
              PushMessageDataInit data;
            };

            [Constructor(DOMString type, optional PushEventInit eventInitDict), Exposed=ServiceWorker]
            interface PushEvent : ExtendableEvent {
              readonly attribute PushMessageData? data;
            };
          </pre>
          <p>
            When a constructor of the <a>PushEvent</a> interface, or of an interface that inherits
            from the <a>PushEvent</a> interface, is invoked, the usual <a>steps for constructing
            events</a> are extended to include the following steps:
          </p>
          <ol>
            <li>If <var>eventInitDict</var>'s <code>data</code> member is not present, set the <code>
            data</code> attribute of the event to <code>null</code> and terminate these steps.
            </li>
            <li>Set <var>b</var> to the result of <a data-lt="extract a byte sequence">extracting a
            byte sequence</a> from the "<code>data</code>" member of <var>eventInitDict</var>.
            </li>
            <li>Set the <code>data</code> attribute of the event to a new <a>PushMessageData</a>
            instance with <code>bytes</code> set to <var>b</var>.
            </li>
          </ol>
          <p>
            The <dfn>data</dfn> attribute contains the data included in the <a>push message</a> when
            included and the <a>user agent</a> verified its authenticity. The value will be set to
            <code>null</code> in all other cases.
          </p>
        </section>
        <section>
          <h2>
            Receiving a <a>Push Message</a>
          </h2>
          <p>
            When the <a>user agent</a> receives a <a>push message</a> from the <a>push service</a>,
            it MUST run the following steps.
          </p>
          <ol>
            <li>Let <var>registration</var> be the <a>service worker registration</a> corresponding
            to the <a>push message</a>.
            </li>
            <li>If <var>registration</var> is not found, abort these steps.
            </li>
            <li>Let <var>subscription</var> be the active <a>push subscription</a> for
            <var>registration</var>.
            </li>
            <li>Initialize <var>data</var> to a value of <code>null</code>.
            </li>
            <li>If the <a>push message</a> contains a payload, perform the following steps:
              <ol>
                <li>Decrypt the <a>push message</a> using the private key from the key pair
                associated with <var>subscription</var> and the process described in
                [[!WEBPUSH-ENCRYPTION]]. This produces the plain text of the message.
                </li>
                <li>If the <a>push message</a> could not be decrypted for any reason, perform the
                following steps:
                  <ol>
                    <li>Acknowledge the receipt of the <a>push message</a> according to
                    [[!WEBPUSH-PROTOCOL]]. Though the message was not successfully received and
                    processed, this prevents the push service from attempting to retransmit the
                    message; a badly encrypted message is not recoverable.
                    </li>
                    <li>Discard the <a>push message</a>.
                    </li>
                    <li>Terminate this process.
                    </li>
                  </ol>A <code>push</code> event MUST NOT be fired for a <a>push message</a> that was
                  not successfully decrypted using the key pair associated with the <a>push
                  subscription</a>.
                </li>
                <li>Let <var>data</var> be a new <a>PushMessageData</a> instance with the decrypted
                plain text of the <a>push message</a>.
                </li>
              </ol>
            </li>
            <li><a>Fire the push event</a> with <var>registration</var> and <var>data</var>, and
            set <var>event</var> to the returned <a>trusted event</a>.
            </li>
            <li>Run the following steps in parallel:
              <ol>
                <li>Wait for all of the promises in the <a>extend lifetime promises</a> of
                <var>event</var> to resolve.
                </li>
                <li>If all the promises resolve successfully, acknowledge the receipt of the
                <a>push message</a> according to [[!WEBPUSH-PROTOCOL]] and abort these steps.
                </li>
                <li>
                  <p>
                    If the same <a>push message</a> has been delivered to a <a>service worker
                    registration</a> multiple times unsuccessfully, acknowledge the receipt of
                    the <a>push message</a> according to [[!WEBPUSH-PROTOCOL]].
                  </p>
                  <p>
                    Acknowledging the <a>push message</a> causes the <a>push service</a> to stop
                    delivering the message and to report success to the <a>application
                    server</a>. This prevents the same <a>push message</a> from being retried by
                    the <a>push service</a> indefinitely.
                  </p>
                  <p>
                    Acknowledging also means that an <a>application server</a> could incorrectly
                    receive a delivery receipt indicating successful delivery of the <a>push
                    message</a>. Therefore, multiple rejections SHOULD be permitted before
                    acknowledging; allowing at least three attempts is recommended.
                  </p>
                </li>
              </ol>
            </li>
          </ol>
        </section>
      </section>
      <section>
        <h2>
          The <dfn>pushsubscriptionchange</dfn> Event
        </h2>
        <p>
          The <a>pushsubscriptionchange</a> event indicates a change in a <a>push subscription</a>
          that was triggered outside of the application's control, for example because it has been
          refreshed, revoked or lost.
        </p>
        <p>
          To <dfn>fire the pushsubscriptionchange event</dfn> given a
          <a>service worker registration</a> of <var>registration</var>, <var>newSubscription</var>
          and <var>oldSubscription</var>, the <a>user agent</a> must run the following steps:
        </p>
        <ol>
          <li>Create a <a>trusted event</a>, <var>event</var>, that uses the
          <a>PushSubscriptionChangeEvent</a> interface, with the event type
          <code>pushsubscriptionchange</code>, which does not bubble, is not cancelable, and has no
          default action.
          </li>
          <li>Set the <code>newSubscription</code> attribute of <var>event</var> to
          <var>newSubscription</var>.
          </li>
          <li>Set the <code>oldSubscription</code> attribute of <var>event</var> to
          <var>oldSubscription</var>.
          </li>
          <li>Invoke the <a>Handle Functional Event</a> algorithm with <var>event</var> and
          <var>registration</var>, and <var>callbackSteps</var> set to the following steps:
            <ol>
              <li>Set <var>global</var> to the global object associated with the
              <var>registration</var>.
              </li>
              <li>Dispatch <var>event</var> to <var>global</var>.
              </li>
            </ol>
          </li>
        </ol>
        <p class="note">
          Consider using a more reliable synchronization mechanism such as [[WEB-BACKGROUND-SYNC]]
          when sending the details of the new <a>push subscription</a> to your
          <a>application server</a>. The user might be subject to unreliable network conditions that
          could cause a fetch to fail.
        </p>

        <section data-dfn-for="PushSubscriptionChangeEvent">
          <h2>
            <dfn>PushSubscriptionChangeEvent</dfn> Interface
          </h2>
          <pre class="idl">
            dictionary PushSubscriptionChangeInit : ExtendableEventInit {
              PushSubscription newSubscription = null;
              PushSubscription oldSubscription = null;
            };

            [Constructor(DOMString type, optional PushSubscriptionChangeInit eventInitDict), Exposed=ServiceWorker]
            interface PushSubscriptionChangeEvent : ExtendableEvent {
              readonly attribute PushSubscription? newSubscription;
              readonly attribute PushSubscription? oldSubscription;
            };
          </pre>
          <p>
            The <dfn>newSubscription</dfn> attribute contains the details of the
            <a>push subscription</a> that is valid per invocation of the <a>pushsubscriptionchange</a>
            event. The value will be <code>null</code> when no new <a>push subscription</a> could be
            established, for example because the <a>webapp</a> has lost <a>express permission</a>.
          </p>
          <p>
            The <dfn>oldSubscription</dfn> attribute contains the details of the
            <a>push subscription</a> that SHOULD NOT be used anymore. The value will be
            <code>null</code> when the <a>user agent</a> is not able to provide the full set of
            details, for example because of partial database corruption.
          </p>
        </section>
      </section>
    </section>
    <section data-dfn-for="PushPermissionState">
      <h2>
        <dfn>PushPermissionState</dfn> Enumeration
      </h2>
      <pre class="idl">
        enum PushPermissionState {
          "denied",
          "granted",
          "prompt",
        };
      </pre>
      <table class="simple">
        <tr>
          <th>
            Enumeration
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            <dfn>granted</dfn>
          </td>
          <td>
            The <a>webapp</a> has permission to use the Push API.
          </td>
        </tr>
        <tr>
          <td>
            <dfn>denied</dfn>
          </td>
          <td>
            The <a>webapp</a> has been denied permission to use the Push API.
          </td>
        </tr>
        <tr>
          <td>
            <dfn>prompt</dfn>
          </td>
          <td>
            The <a>webapp</a> needs to ask for permission in order to use the Push API.
          </td>
        </tr>
      </table>
    </section>
    <section class="appendix">
      <h2>
        Acknowledgements
      </h2>
      <p>
        The editors would like to express their gratitude to the Mozilla and Telefónica Digital
        teams implementing the Firefox OS Push message solution and specially to Doug Turner,
        Nikhil Marathe, Fernando R. Sela, Guillermo López, Antonio Amaya, José Manuel Cantera and
        Albert Crespell, for their technical guidance, implementation work and support.
      </p>
    </section>
  </body>
</html>
