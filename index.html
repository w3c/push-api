<!DOCTYPE html>
<html>
  <head>
    <title>
      Push API
    </title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove'>
    </script>
    <script class="remove">
    // (this is to make tidy happy)
      // See http://www.w3.org/respec/ for ReSpec documentation.
      var respecConfig = {
          specStatus: "ED",
          shortName: "push-api",

          previousPublishDate: "2013-08-15",
          previousMaturity: "WD",
          edDraftURI: "https://w3c.github.io/push-api/",

          editors: [
            {
              name: "MichaÃ«l van Ouwerkerk",
              company: "Google",
              companyURL: "https://www.google.com/",
              w3cid: "67729"
            },
            {
              name: "Martin Thomson",
              company: "Mozilla Foundation",
              companyURL: "http://www.mozilla.org/",
              w3cid: "68503"
            },
            {
              name: "Bryan Sullivan",
              company: "AT&T",
              companyURL: "http://www.att.com/",
              note: "until <time>2015-05-01</time>",
              w3cid: "41539"
            },
            {
              name: "Eduardo Fullea",
              company: "Telefonica",
              companyURL: "http://www.telefonica.com/",
              note: "until <time>2015-05-01</time>",
              w3cid: "53513"
            }
          ],

          wg: "Web Applications Working Group",
          wgURI: "http://www.w3.org/2008/webapps/",
          wgPublicList: "public-webapps",
          subjectPrefix: "[Push API]",

          // This is important for Rec-track documents, do not copy a patent URI
          // from a random document unless you know what you're doing. If in
          // doubt ask your friendly neighbourhood Team Contact.
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/42538/status",

          noLegacyStyle: true,

          otherLinks: [
            {
              key: "Participate",
              data: [
                {
                  value: "Mailing list",
                  href: "http://lists.w3.org/Archives/Public/public-webapps/"
                },
                {
                  value: "Browse open issues",
                  href: "https://github.com/w3c/push-api/issues"
                },
                {
                  value: "File a bug",
                  href: "https://github.com/w3c/push-api/issues/new"
                },
              ]
            },
          ],

          localBiblio: {
            "NOTIFICATIONS": {
              title: "Notifications API",
              href: "https://notifications.spec.whatwg.org/",
              authors: [
                "Anne van Kesteren",
              ],
              status: "Living Standard",
              publisher: "WHATWG"
            }
          }
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        The <cite>Push API</cite> provides <a>webapps</a> with scripted access to server-sent
        messages, for simplicity referred to here as <a>push messages</a>, as delivered by <a>push
        services</a>. A <a>push service</a> allows an <a>application server</a> to send messages to
        a <a>webapp</a>, regardless of whether the <a>webapp</a> is currently active on the <a>user
        agent</a>. The <a>push message</a> will be delivered to a <a>Service Worker</a>, which
        could then store the message's data or display a notification to the user.
      </p>
      <p>
        This specification is designed to promote compatibility with any delivery method for
        <a>push messages</a> from <a>push services</a> to <a>user agents</a>.
      </p>
    </section>
    <section id='sotd'></section>
    <section class='informative' id="introduction">
      <h2>
        Introduction
      </h2>
      <p>
        As defined here, <a>push services</a> support delivery of <a>application server</a>
        messages in the following contexts and related use cases:
      </p>
      <ul>
        <li>the user is actively involved in the use of a <a>webapp</a>: this relates to any normal
        use case in which a <a>webapp</a> user may benefit from <a>push messages</a> while the user
        is actively using the <a>webapp</a>
        </li>
        <li>the user is not actively involved in the use of a <a>webapp</a>, but the <a>webapp</a>
        is active in a window of the browser or executing as a web worker: this relates to use
        cases such as social networking, messaging, web feed readers, etc in which the user may not
        be actively using a <a>webapp</a> but still benefits from <a>push messages</a> being sent
        to (or via) the <a>webapp</a>, to keep the user up-to-date
        </li>
        <li>the <a>webapp</a> is not currently active in a browser window: this relates to use
        cases in which the user may close the <a>webapp</a>, but still benefits from the
        <a>webapp</a> being able to be restarted when a <a>push message</a> is received, e.g. the
        WebRTC use case in which an incoming call can invoke the WebRTC <a>webapp</a>
        </li>
        <li>multiple <a>webapps</a> are running, but <a>push messages</a> are delivered only to the
        <a>webapp</a> that requested them, e.g. any normal use case in which multiple
        <a>webapps</a> are active in the browser and utilizing <a>push services</a>
        </li>
        <li>multiple instances of the same <a>webapp</a> are active in the browser, and <a>push
        messages</a> specific to each instance of the <a>webapp</a> are delivered only to the
        specific instance, e.g. when a mail <a>webapp</a> is active in two windows using different
        mail accounts
        </li>
        <li>multiple instances of the same <a>webapp</a> are active in different browsers, and push
        messages are delivered to a set of instances of the <a>webapp</a>, e.g. when a mail
        <a>webapp</a> is active in two browsers using the same email account
        </li>
        <li>multiple instances of the same <a>webapp</a> are active in different browsers, and push
        messages are delivered to all instances of the <a>webapp</a>, e.g. when a message is to be
        broadcasted to all users of the <a>webapp</a>
        </li>
      </ul>
    </section>
    <section id="conformance">
      <p>
        This specification defines conformance criteria that apply to a single product: the
        <dfn data-lt="user agent|user agents">user agent</dfn> that implements the interfaces that
        it contains.
      </p>
      <p>
        Implementations that use ECMAScript to implement the APIs defined in this specification
        MUST implement them in a manner consistent with the ECMAScript Bindings defined in the Web
        IDL specification [[!WEBIDL]].
      </p>
    </section>
    <section>
      <h2>
        Dependencies
      </h2>
      <p>
        The terms <dfn><a href="http://www.w3.org/TR/html5/webappapis.html#event-handlers">event
        handler</a></dfn>, <dfn><a href=
        "http://www.w3.org/TR/html5/webappapis.html#event-handler-event-type">event handler event
        type</a></dfn>, <dfn><a href=
        "http://www.w3.org/TR/html5/webappapis.html#queue-a-task">queue a task</a></dfn>, and
        <dfn><a href="http://www.w3.org/TR/html5/webappapis.html#fire-a-simple-event">fire a simple
        event</a></dfn> are defined in [[!HTML5]].
      </p>
      <p>
        <code><a href=
        'http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects'><dfn>Promise</dfn></a></code>,
        and <code><a href=
        "https://people.mozilla.org/~jorendorff/es6-draft.html#sec-json.parse"><dfn>JSON.parse</dfn></a></code>
        are defined in [[!ECMASCRIPT]].
      </p>
      <p>
        <code><a href="http://www.w3.org/TR/dom/#eventinit"><dfn>EventInit</dfn></a></code>,
        <code><a href="http://www.w3.org/TR/dom/#domexception"><dfn>DOMException</dfn></a></code>,
        <code><a href="http://www.w3.org/TR/dom/#aborterror"><dfn>AbortError</dfn></a></code>,
        <code><a href=
        "http://www.w3.org/TR/dom/#invalidstateerror"><dfn>InvalidStateError</dfn></a></code>,
        <code><a href=
        "http://www.w3.org/TR/dom/#securityerror"><dfn>SecurityError</dfn></a></code>,
        <code><a href="http://www.w3.org/TR/dom/#networkerror"><dfn>NetworkError</dfn></a></code>,
        and <a href="http://www.w3.org/TR/dom/#concept-event-constructor"><dfn>steps for
        constructing events</dfn></a> are defined in [[!DOM]].
      </p>
      <p>
        The terms <a href="http://www.w3.org/TR/service-workers/#dfn-service-worker"><dfn>service
        worker</dfn></a>, <a href=
        "http://www.w3.org/TR/service-workers/#dfn-service-worker-registration"><dfn>service worker
        registration</dfn></a>, <a href=
        "http://www.w3.org/TR/service-workers/#dfn-installing-worker"><dfn>installing
        worker</dfn></a>, <a href=
        "http://www.w3.org/TR/service-workers/#dfn-waiting-worker"><dfn>waiting worker</dfn></a>,
        and <a href="http://www.w3.org/TR/service-workers/#dfn-active-worker"><dfn>active
        worker</dfn></a>, and the types <code><a href=
        "http://www.w3.org/TR/service-workers/#service-worker-registration-interface"><dfn>ServiceWorkerRegistration</dfn></a></code>,
        <code><a href=
        "http://www.w3.org/TR/service-workers/#service-worker-global-scope-interface"><dfn>ServiceWorkerGlobalScope</dfn></a></code>,
        <code><a href=
        "http://www.w3.org/TR/service-workers/#extendable-event-interface"><dfn>ExtendableEvent</dfn></a></code>,
        and <code><a href=
        "http://www.w3.org/TR/service-workers/#extendable-event-init-dictionary"><dfn>ExtendableEventInit</dfn></a></code>
        are defined in [[!SERVICE-WORKERS]].
      </p>
      <p>
        The algorithms <a href="http://www.w3.org/TR/encoding/#utf-8-encode"><dfn>utf-8
        encode</dfn></a>, and <a href="http://www.w3.org/TR/encoding/#utf-8-decode"><dfn>utf-8
        decode</dfn></a> are defined in [[!ENCODING]].
      </p>
      <p>
        <code><a href="http://www.w3.org/TR/FileAPI/#blob"><dfn>Blob</dfn></a></code> is defined in
        [[!FILEAPI]].
      </p>
      <p>
        <code><a href="http://www.w3.org/TR/WebIDL/#idl-any"><dfn>Any</dfn></a></code>,
        <code><a href=
        "http://heycam.github.io/webidl/#idl-ArrayBuffer"><dfn>ArrayBuffer</dfn></a></code>,
        <code><a href=
        "http://heycam.github.io/webidl/#common-BufferSource"><dfn>BufferSource</dfn></a></code>,
        and <code><a href=
        "http://heycam.github.io/webidl/#idl-USVString"><dfn>USVString</dfn></a></code> are defined
        in [[!WEBIDL]].
      </p>
      <p>
        The <dfn><a href="http://datatracker.ietf.org/doc/draft-thomson-webpush-protocol/">web push
        protocol</a></dfn> describes a protocol that enables communication between a <a>user
        agent</a> or <a>application server</a> and a <a>push service</a>. Alternative protocols
        could be used in place of this protocol, but this specification assumes the use of this
        protocol; alternative protocols are expected to provide compatible semantics. Note: this is
        currently only a proposed protocol.
      </p>
    </section>
    <section>
      <h2>
        Concepts
      </h2>
      <section>
        <h2>
          Webapp
        </h2>
        <p>
          The term <dfn data-lt="webapp|webapps">webapp</dfn> refers to a Web application, i.e. an
          application implemented using Web technologies, and executing within the context of a Web
          <a>user agent</a>, e.g. a Web browser or other Web runtime environment.
        </p>
        <p>
          The term <dfn data-lt="application server|application servers">application server</dfn>
          refers to server-side components of a <a>webapp</a>.
        </p>
      </section>
      <section>
        <h2>
          Push message
        </h2>
        <p>
          A <dfn data-lt="push message|push messages">push message</dfn> is data sent to a
          <a>webapp</a> from an <a>application server</a>.
        </p>
        <p>
          A <a>push message</a> is delivered to the <a>active worker</a> associated with the
          <a>push subscription</a> to which the message was submitted. If the worker or its
          <a>webapp</a> is not currently running, the worker is started to enable delivery.
        </p>
      </section>
      <section>
        <h2>
          Push subscription
        </h2>
        <p>
          A <dfn data-lt="push subscription|push subscriptions">push subscription</dfn> is a
          message delivery context established between the <a>user agent</a> and the <a>push
          service</a> on behalf of a <a>webapp</a>, and associated with the <a>webapp</a>'s
          <a>service worker registration</a>.
        </p>
        <p>
          When a <a>push subscription</a> is <dfn data-lt=
          "deactivated|deactivate">deactivated</dfn>, both the <a>user agent</a> and the <a>push
          service</a> MUST delete any stored copies of its details. Subsequent <a>push messages</a>
          for this <a>push subscription</a> MUST NOT be delivered.
        </p>
        <p>
          A <a>push subscription</a> is <a>deactivated</a> when its associated <a>service worker
          registration</a> is unregistered, though a <a>push subscription</a> MAY be
          <a>deactivated</a> earlier.
        </p>
        <p>
          A <a>push subscription</a> has an associated <dfn data-lt=
          "endpoint|endpoints">endpoint</dfn>. It MUST be the absolute URL exposed by the <a>push
          service</a> where the <a>application server</a> can send <a>push messages</a> to. An
          <a>endpoint</a> MUST uniquely identify the <a>push subscription</a>.
        </p>
      </section>
      <section>
        <h2>
          Push service
        </h2>
        <p>
          The term <dfn data-lt="push service|push services">push service</dfn> refers to a system
          that allows <a>application servers</a> to send <a>push messages</a> to a <a>webapp</a>. A
          push service serves the <a>endpoint</a> or <a>endpoints</a> for the <a>push
          subscriptions</a> it serves.
        </p>
      </section>
      <section>
        <h2>
          Permission
        </h2>
        <p>
          The term <dfn>express permission</dfn> refers to an act by the user, e.g. via user
          interface or host device platform features, via which the user approves the permission of
          a <a>webapp</a> to access the Push API.
        </p>
      </section>
    </section>
    <section>
      <h2>
        Security and privacy considerations
      </h2>
      <p>
        <a>User agents</a> MUST NOT provide Push API access to <a>webapps</a> without the
        <a>express permission</a> of the user. <a>User agents</a> MUST acquire consent for
        permission through a user interface for each call to the <code>subscribe()</code> method,
        unless a previous permission grant has been persisted, or a prearranged trust relationship
        applies. Permissions that are preserved beyond the current browsing session MUST be
        revocable.
      </p>
      <p>
        The <a>user agent</a> MAY consider the <code><a>PushSubscriptionOptions</a></code> when
        acquiring permission or determining the permission status.
      </p>
      <p>
        When a permission is revoked, all <a>push subscriptions</a> created with that permission
        MUST be <a>deactivated</a>.
      </p>
      <p>
        When a <a>service worker registration</a> is unregistered, any associated <a>push
        subscription</a> MUST be <a>deactivated</a>.
      </p>
      <p>
        The <a>endpoint</a> of a <a>deactivated</a> <a>push subscription</a> MUST NOT be reused for
        a new <a>push subscription</a>. This prevents the creation of a persistent identifier that
        the user cannot remove. This also prevents reuse of the details of one <a>push
        subscription</a> to send <a>push messages</a> to another <a>push subscription</a>.
      </p>
      <p>
        <a>User agents</a> MUST implement the Push API to be HTTPS-only. SSL-only support provides
        better protection for the user against man-in-the-middle attacks intended to obtain push
        subscription data. Browsers may ignore this rule for development purposes only.
      </p>
    </section>
    <section class='informative' id="pushframework">
      <h2>
        Push Framework
      </h2>
      <p>
        Although <a>push services</a> are expected to differ in deployment, a typical deployment is
        expected to have the following general entities and example operation for delivery of
        <a>push messages</a>:
      </p>
      <ul>
        <li>
          <a>Application servers</a> request delivery of a <a>push message</a> to a <a>webapp</a>
          via a RESTful API exposed by a <a>push service</a>
        </li>
        <li>The <a>push service</a> delivers the message to a specific <a>user agent</a>
        </li>
        <li>The <a>user agent</a> delivers the <a>push message</a> to the specific <a>webapp</a>
        intended to receive it.
        </li>
      </ul>
      <p>
        This overall framework allows <a>application servers</a> to inform <a>webapps</a> that new
        data is available at the <a>application server</a>, or pass the new data directly to the
        <a>webapp</a> in the <a>push message</a>.
      </p>
      <p>
        The push API enables delivery of arbitrary application data to <a>webapps</a>, and makes no
        assumptions about the over-the-air/wire protocol used by <a>push services</a>. As such, the
        details of what types of data flow through a <a>push services</a> for a particular
        <a>webapp</a> are specific to the <a>push service</a> and <a>webapp</a>. As needed,
        clarification about what data flows over-the-air/wire should be sought from <a>push
        service</a> operators or <a>webapp</a> developers.
      </p>
      <p>
        The following code and diagram illustrate a hypothetical use of the push API.
      </p>
      <section class="informative">
        <h2>
          Example
        </h2>
        <pre class="example highlight">
// https://example.com/serviceworker.js
this.onpush = function(event) {
  console.log(event.data);
  // From here we can write the data to IndexedDB, send it to any open
  // windows, display a notification, etc.
}

// https://example.com/webapp.js
navigator.serviceWorker.register('serviceworker.js').then(
  function(serviceWorkerRegistration) {
    serviceWorkerRegistration.pushManager.subscribe().then(
      function(pushSubscription) {
        console.log(pushSubscription.endpoint);
        // The push subscription details needed by the application
        // server are now available, and can be sent to it using,
        // for example, an XMLHttpRequest.
      }, function(error) {
        // During development it often helps to log errors to the
        // console. In a production environment it might make sense to
        // also report information about errors back to the
        // application server.
        console.log(error);
      }
    );
  });
</pre>
      </section>
      <section class="informative">
        <h2>
          Sequence diagram
        </h2>
        <figure>
          <a href="sequence_diagram.png"><img src="sequence_diagram.png" width="795" height="870"
          alt=
          "Example flow of events for subscription, push message delivery, and unsubscription"></a>
          <figcaption>
            Example flow of events for subscription, push message delivery, and unsubscription
          </figcaption>
        </figure>
      </section>
      <section>
        <h3>
          Push service use
        </h3>
        <p>
          A <code>PushSubscription</code> contains all the information needed to send a <a>push
          message</a>. A <a>push message</a> can be delivered using the <a>web push protocol</a>.
        </p>
        <p>
          The <code><a>endpoint</a></code> of a <code>PushSubscription</code> is a URI that allows
          an <a>application server</a> to request delivery of a <a>push message</a> to a <a>push
          subscription</a>.
        </p>
      </section>
    </section>
    <section>
      <h2>
        Extensions to the <a>ServiceWorkerRegistration</a> interface
      </h2>
      <p>
        The Service Worker specification defines a <code>ServiceWorkerRegistration</code> interface
        [[!SERVICE-WORKERS]], which this specification extends.
      </p>
      <dl title="partial interface ServiceWorkerRegistration" class="idl">
        <dt>
          readonly attribute PushManager pushManager
        </dt>
      </dl>
      <p>
        The <code><dfn id="widl-ServiceWorkerRegistration-pushManager">pushManager</dfn></code>
        attribute exposes a <code><a>PushManager</a></code>, which has an associated <a>service
        worker registration</a> represented by the <code><a>ServiceWorkerRegistration</a></code> on
        which the attribute is exposed.
      </p>
    </section>
    <section>
      <h2>
        <a>PushManager</a> interface
      </h2>
      <p>
        The <a>PushManager</a> interface defines the operations to access <a>push services</a>.
      </p>
      <dl title="interface PushManager" class="idl">
        <dt>
          Promise&lt;PushSubscription&gt; subscribe (optional PushSubscriptionOptions options)
        </dt>
        <dt>
          Promise&lt;PushSubscription?&gt; getSubscription ()
        </dt>
        <dt>
          Promise&lt;PushPermissionState&gt; permissionState (optional PushSubscriptionOptions
          options)
        </dt>
      </dl>
      <p>
        The <code><dfn id=
        "widl-PushManager-subscribe-Promise-PushSubscription--PushSubscriptionOptions-options">subscribe</dfn></code>
        method when invoked MUST run the following steps:
      </p>
      <ol>
        <li>Let <var>promise</var> be a new <a><code>Promise</code></a>.
        </li>
        <li>Return <var>promise</var> and continue the following steps asynchronously.
        </li>
        <li>If the scheme of the document url is not <code>https</code>, reject <var>promise</var>
        with a <code><a>DOMException</a></code> whose name is "<code><a>SecurityError</a></code>"
        and terminate these steps.
        </li>
        <li>Let <var>registration</var> be the <code><a>PushManager</a></code>'s associated
        <a>service worker registration</a>.
        </li>
        <li>If <var>registration</var> has no <a>active worker</a>, run the following substeps:
          <ol>
            <li>If <var>registration</var> has no <a>installing worker</a> and no <a>waiting
            worker</a>, reject <var>promise</var> with a <code><a>DOMException</a></code> whose
            name is "<code><a>InvalidStateError</a></code>" and terminate these steps.
            </li>
            <li>Wait for the <a>installing worker</a> or <a>waiting worker</a> of
            <var>registration</var> to become its <a>active worker</a>.
            </li>
            <li>If <var>registration</var> fails to activate either worker, reject
            <var>promise</var> with a <code><a>DOMException</a></code> whose name is
            "<code><a>InvalidStateError</a></code>" and terminate these steps.
            </li>
            <li>Once <var>registration</var> has an <a>active worker</a>, proceed with the steps
            below.
            </li>
          </ol>
        </li>
        <li>Ask the user whether they allow the <a>webapp</a> to receive <a>push messages</a>,
        unless a prearranged trust relationship applies or the user has already granted or denied
        permission explicitly for this <a>webapp</a>.
        </li>
        <li>If not granted, reject <var>promise</var> with a <code><a>DOMException</a></code> whose
        name is "<code><a>PermissionDeniedError</a></code>" and terminate these steps.
        </li>
        <li>If the <a>webapp</a> is already subscribed, run the following substeps:
          <ol>
            <li>Retrieve the <a>push subscription</a> associated with the <a>webapp</a>.
            </li>
            <li>If there is an error, reject <var>promise</var> with a
            <code><a>DOMException</a></code> whose name is "<code><a>AbortError</a></code>" and
            terminate these steps.
            </li>
            <li>When the request has been completed, resolve <var>promise</var> with a
            <a><code>PushSubscription</code></a> providing the details of the retrieved <a>push
            subscription</a>.
            </li>
          </ol>
        </li>
        <li>Make a request to the push service to create a new <a>push subscription</a> for the <a>
          webapp</a>.
        </li>
        <li>If there is an error, reject <var>promise</var> with a <code><a>DOMException</a></code>
        whose name is "<code><a>AbortError</a></code>" and terminate these steps.
        </li>
        <li>When the request has been completed, resolve <var>promise</var> with a
        <a><code>PushSubscription</code></a> providing the details of the new <a>push
        subscription</a>.
        </li>
      </ol>
      <p>
        The <code><dfn id=
        "widl-PushManager-getSubscription-Promise-PushSubscription">getSubscription</dfn></code>
        method when invoked MUST run the following steps:
      </p>
      <ol>
        <li>Let <var>promise</var> be a new <a><code>Promise</code></a>.
        </li>
        <li>Return <var>promise</var> and continue the following steps asynchronously.
        </li>
        <li>If the <a>webapp</a> is not subscribed, resolve <var>promise</var> with null.
        </li>
        <li>Retrieve the <a>push subscription</a> associated with the <a>webapp</a>.
        </li>
        <li>If there is an error, reject <var>promise</var> with a <code><a>DOMException</a></code>
        whose name is "<code><a>AbortError</a></code>" and terminate these steps.
        </li>
        <li>When the request has been completed, resolve <var>promise</var> with a
        <a><code>PushSubscription</code></a> providing the details of the retrieved <a>push
        subscription</a>.
        </li>
      </ol>
      <p>
        The <code><dfn id=
        "widl-PushManager-permissionState-Promise-PushPermissionState--PushSubscriptionOptions-options">
        permissionState</dfn></code> method when invoked MUST run the following steps:
      </p>
      <ol>
        <li>Let <var>promise</var> be a new <a><code>Promise</code></a>.
        </li>
        <li>Return <var>promise</var> and continue the following steps asynchronously.
        </li>
        <li>Retrieve the push permission status (<a><code>PushPermissionState</code></a>) of the
        requesting <a>webapp</a>.
        </li>
        <li>If there is an error, reject <var>promise</var> with no arguments and terminate these
        steps.
        </li>
        <li>When the request has been completed, resolve <var>promise</var> with
        <a><code>PushPermissionState</code></a> providing the push permission status.
        </li>
      </ol>
      <p>
        Permission to use the push service can be persistent, that is, it does not need to be
        reconfirmed for subsequent subscriptions if a valid permission exists.
      </p>
      <p>
        If there is a need to ask for permission, it needs to be done by invoking the
        <a><code>subscribe</code></a> method.
      </p>
      <section>
        <h2>
          <a>PushSubscriptionOptions</a> dictionary
        </h2>
        <p>
          A <a>PushSubscriptionOptions</a> object represents additional options associated with a
          <a>push subscription</a>. The <a>user agent</a> MAY consider these options when
          requesting <a>express permission</a> from the user. When an option is considered, the
          <a>user agent</a> SHOULD enforce it on incoming <a>push messages</a>.
        </p>
        <dl title="dictionary PushSubscriptionOptions" class="idl">
          <dt>
            boolean userVisibleOnly = false
          </dt>
        </dl>
        <p>
          The <code><dfn id=
          "widl-PushSubscriptionOptions-userVisibleOnly">userVisibleOnly</dfn></code> option, when
          set to <code>true</code>, indicates that the <a>push subscription</a> will only be used
          for <a>push messages</a> whose effect is made visible to the user, for example by
          displaying a Web Notification. [[NOTIFICATIONS]]
        </p>
      </section>
    </section>
    <section>
      <h2>
        <a>PushSubscription</a> interface
      </h2>
      <p>
        A <a>PushSubscription</a> object represents a <a>push subscription</a>.
      </p>
      <dl title="interface PushSubscription" class="idl">
        <dt>
          readonly attribute USVString endpoint
        </dt>
        <dt>
          Promise&lt;boolean&gt; unsubscribe ()
        </dt>
        <dt>
          serializer = {attribute}
        </dt>
      </dl>
      <p>
        When getting the <code id=
        "widl-PushSubscription-endpoint"><strong><em>endpoint</em></strong></code> attribute, the
        <a>user agent</a> MUST return the <a>endpoint</a> associated with the <a>push
        subscription</a>.
      </p>
      <p>
        The <code><dfn id=
        "widl-PushSubscription-unsubscribe-Promise-boolean">unsubscribe</dfn></code> method when
        invoked MUST run the following steps:
      </p>
      <ol>
        <li>Let <var>promise</var> be a new <a><code>Promise</code></a>.
        </li>
        <li>Return <var>promise</var> and continue the following steps asynchronously.
        </li>
        <li>If the <a>push subscription</a> has already been <a>deactivated</a>, resolve
        <var>promise</var> with <code>false</code> and terminate these steps.
        </li>
        <li>Make a request to the <a>push service</a> to <a>deactivate</a> the <a>push
        subscription</a>.
        </li>
        <li>If it was not possible to access the <a>push service</a>, reject <var>promise</var>
        with a "<code><a>NetworkError</a></code>" exception and terminate these steps.
        </li>
        <li>When the request has been completed, resolve <var>promise</var> with <code>true</code>.
        </li>
      </ol>
    </section>
    <section>
      <h2>
        <a>PushMessageData</a> interface
      </h2>
      <dl title="interface PushMessageData" class="idl">
        <dt>
          ArrayBuffer arrayBuffer ()
        </dt>
        <dt>
          Blob blob ()
        </dt>
        <dt>
          Any json ()
        </dt>
        <dt>
          USVString text ()
        </dt>
      </dl>
      <p>
        <a>PushMessageData</a> objects have an associated <dfn>bytes</dfn> (a byte sequence) set on
        creation.
      </p>
      <p>
        The <code><dfn id="widl-PushMessageData-arrayBuffer-ArrayBuffer">arrayBuffer()</dfn></code>
        method, when invoked, MUST return an <a><code>ArrayBuffer</code></a> whose contents are
        <var>bytes</var>.
      </p>
      <p>
        The <code><dfn id="widl-PushMessageData-blob-Blob">blob()</dfn></code> method, when
        invoked, MUST return a <a><code>Blob</code></a> whose contents are <var>bytes</var> and
        <var>type</var> is not provided.
      </p>
      <p>
        The <code><dfn id="widl-PushMessageData-json-Any">json()</dfn></code> method, when invoked,
        MUST return the result of invoking the initial value of <a><code>JSON.parse</code></a> with
        the result of running <a>utf-8 decode</a> on <var>bytes</var> as argument. Re-throw any
        exceptions thrown by <a><code>JSON.parse</code></a>.
      </p>
      <p>
        The <code><dfn id="widl-PushMessageData-text-USVString">text()</dfn></code> method, when
        invoked, MUST return the result of running <a>utf-8 decode</a> on <var>bytes</var>.
      </p>
      <div class="idl" title="typedef USVString PushMessageDataInit"></div>
      <p class="note">
        In future, <a>PushMessageDataInit</a> is likely to be a union type that includes types such
        as <a><code>Blob</code></a> and <a><code>BufferSource</code></a>. The <a data-lt=
        "extract a byte sequence">algorithm</a> below would be extended, rather like the Fetch
        standard's <a href="https://fetch.spec.whatwg.org/#concept-bodyinit-extract">extract a byte
        stream</a> algorithm.
      </p>
      <p>
        To <dfn>extract a byte sequence</dfn> from <var>object</var>, run these steps:
      </p>
      <ol>
        <li>Let <var>bytes</var> be an empty byte sequence.
        </li>
        <li>Switch on <var>object</var>'s type:
          <dl>
            <dt>
              <a><code>USVString</code></a>
            </dt>
            <dd>
              Set <var>bytes</var> to the result of running <a>utf-8 encode</a> on
              <var>object</var>.
            </dd>
          </dl>
        </li>
        <li>Return <var>bytes</var>.
        </li>
      </ol>
    </section>
    <section>
      <h2>
        Events
      </h2>
      <p>
        The Service Worker specification defines a <code>ServiceWorkerGlobalScope</code> interface
        [[!SERVICE-WORKERS]], which this specification extends.
      </p>
      <dl title="partial interface ServiceWorkerGlobalScope" class="idl">
        <dt>
          attribute EventHandler onpush
        </dt>
        <dt>
          attribute EventHandler onpushsubscriptionchange
        </dt>
      </dl>
      <p>
        The <code><dfn id="widl-ServiceWorkerGlobalScope-onpush">onpush</dfn></code> attribute is
        an <a>event handler</a> whose corresponding <a>event handler event type</a> is
        <code>push</code>.
      </p>
      <p>
        The <code><dfn id=
        "widl-ServiceWorkerGlobalScope-onpushsubscriptionchange">onpushsubscriptionchange</dfn></code>
        attribute is an <a>event handler</a> whose corresponding <a>event handler event type</a> is
        <code>pushsubscriptionchange</code>.
      </p>
      <section>
        <h2>
          The <code>push</code> event
        </h2>
        <p>
          The <a>PushEvent</a> interface represents a received <a>push message</a>.
        </p>
        <dl title=
        "[Constructor(DOMString type, optional PushEventInit eventInitDict), Exposed=ServiceWorker] interface PushEvent : ExtendableEvent"
        class="idl" data-merge="PushEventInit">
          <dt>
            readonly attribute PushMessageData data
          </dt>
        </dl>
        <dl title="dictionary PushEventInit : ExtendableEventInit" class="idl">
          <dt>
            PushMessageDataInit data
          </dt>
        </dl>
        <p>
          Upon receiving a <a>push message</a> for a <a>push subscription</a> from the <a>push
          service</a> the <a>user agent</a> MUST run the following steps:
        </p>
        <ol>
          <li>If the <a>Service Worker</a> associated with the <a>webapp</a> is not running, start
          it.
          </li>
          <li>Let <var>scope</var> be the <code>ServiceWorkerGlobalScope</code> of the <a>Service
          Worker</a> associated with the <a>webapp</a>.
          </li>
          <li>Let <var>event</var> be a new <a>PushEvent</a>, whose <code id="widl-PushEvent-data">
            data</code> attribute is a new <a>PushMessageData</a> with <a>bytes</a> set to the
            binary message data received by the <a>user agent</a> in the <a>push message</a>, or an
            empty byte sequence if no data was received.
          </li>
          <li>
            <a>Queue a task</a> to <a data-lt="fire a simple event">fire <var>event</var> as a
            simple event</a> named <code>push</code> at <var>scope</var>.
          </li>
        </ol>
        <p>
          When a constructor of the <a>PushEvent</a> interface, or of an interface that inherits
          from the <a>PushEvent</a> interface, is invoked, the usual <a>steps for constructing
          events</a> MUST be modified as follows: instead of setting the <code>data</code>
          attribute of the event to the value of the <var>eventInitDict</var>'s "<code id=
          "widl-PushEventInit-data">data</code>" member, set the <code>data</code> attribute to a
          new <a>PushMessageData</a> with <a>bytes</a> set to the result of <a data-lt=
          "extract a byte sequence">extracting a byte sequence</a> from that dictionary member, or
          an empty byte sequence if <var>eventInitDict</var> is not provided or has no
          "<code>data</code>" member.
        </p>
      </section>
      <section>
        <h2>
          The <code>pushsubscriptionchange</code> event
        </h2>
        <p>
          The <code>pushsubscriptionchange</code> event indicates that a <a>push subscription</a>
          has been invalidated, or will soon be invalidated. For example, the <a>push service</a>
          MAY set an expiration time. A <a>webapp</a> SHOULD attempt to resubscribe while handling
          this event, in order to continue receiving <a>push messages</a>.
        </p>
        <p>
          To fire a <code>pushsubscriptionchange</code> event, the <a>user agent</a> MUST run the
          following steps:
        </p>
        <ol>
          <li>If the <a>Service Worker</a> associated with the <a>webapp</a> is not running, start
          it.
          </li>
          <li>Let <var>scope</var> be the <code>ServiceWorkerGlobalScope</code> of the <a>Service
          Worker</a> associated with the <a>webapp</a>.
          </li>
          <li>
            <a>Queue a task</a> to <a>fire a simple event</a> named
            <code>pushsubscriptionchange</code> at <var>scope</var>.
          </li>
        </ol>
      </section>
    </section>
    <section>
      <h2>
        Enumerations
      </h2>
      <dl class="idl" title="enum PushPermissionState">
        <dt>
          granted
        </dt>
        <dt>
          denied
        </dt>
        <dt>
          prompt
        </dt>
      </dl>
      <table class="simple">
        <tr>
          <th>
            Enumeration
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            <code id="idl-def-PushPermissionState.granted">granted</code>
          </td>
          <td>
            The <a>webapp</a> has permission to use the Push API.
          </td>
        </tr>
        <tr>
          <td>
            <code id="idl-def-PushPermissionState.denied">denied</code>
          </td>
          <td>
            The <a>webapp</a> has been denied permission to use the Push API.
          </td>
        </tr>
        <tr>
          <td>
            <code id="idl-def-PushPermissionState.prompt">prompt</code>
          </td>
          <td>
            The <a>webapp</a> needs to ask for permission in order to use the Push API.
          </td>
        </tr>
      </table>
    </section>
    <section>
      <h2>
        Exceptions
      </h2>
      <p>
        The Push API uses the following new <a>DOMException</a> names.
      </p>
      <table class="simple">
        <tr>
          <th>
            Name
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            <code><dfn>PermissionDeniedError</dfn></code>
          </td>
          <td>
            The operation failed because the user denied permission to use the API.
          </td>
        </tr>
      </table>
    </section>
    <section class="appendix">
      <h2>
        Acknowledgements
      </h2>
      <p>
        The editors would like to express their gratitude to the Mozilla and TelefÃ³nica Digital
        teams implementing the Firefox OS Push message solution and specially to Doug Turner,
        Nikhil Marathe, Fernando R. Sela, Guillermo LÃ³pez, Antonio Amaya, JosÃ© Manuel Cantera and
        Albert Crespell, for their technical guidance, implementation work and support.
      </p>
    </section>
  </body>
</html>
