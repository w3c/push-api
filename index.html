<!DOCTYPE html>
<html lang="en-US">
  <head>
    <title>
      Push API
    </title>
    <meta charset="utf-8">
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
    <script class="remove">
      // See http://www.w3.org/respec/ for ReSpec documentation.
      var respecConfig = {
          specStatus: "ED",
          shortName: "push-api",
          // previousPublishDate: "2013-08-15",
          // previousMaturity: "WD",
          editors: [
            {
              name: "Peter Beverloo",
              company: "Google",
              companyURL: "https://www.google.com/",
              w3cid: "44819"
            },
            {
              name: "Martin Thomson",
              company: "Mozilla Foundation",
              companyURL: "https://www.mozilla.org/",
              w3cid: "68503"
            },
            {
              name: "Bryan Sullivan",
              company: "AT&T",
              companyURL: "http://www.att.com/",
              retiredDate: "2015-05-01",
            },
            {
              name: "Eduardo Fullea",
              company: "Telefonica",
              companyURL: "http://www.telefonica.com/",
              retiredDate: "2015-05-01",
            },
            {
              name: "MichaÃ«l van Ouwerkerk",
              company: "Google",
              companyURL: "https://www.google.com/",
              retiredDate: "2016-11-08",
            }
          ],
          wg: "Web Applications Working Group",
          wgURI: "https://www.w3.org/2019/webapps/",
          wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/114929/status",
          github: "w3c/push-api",
          xref: "web-platform",
      };
    </script>
  </head>
  <body data-cite="service-workers FILEAPI promises-guide">
    <section id="abstract">
      <p>
        The <cite>Push API</cite> enables sending of a <a>push message</a> to a web application via
        a <a>push service</a>. An <a>application server</a> can send a <a>push message</a> at any
        time, even when a web application or <a>user agent</a> is inactive. The <a>push service</a>
        ensures reliable and efficient delivery to the <a>user agent</a>. <a>Push messages</a> are
        delivered to a <a>Service Worker</a> that runs in the origin of the web application, which
        can use the information in the message to update local state or display a notification to
        the user.
      </p>
      <p>
        This specification is designed for use with the <a>web push protocol</a>, which describes
        how an <a>application server</a> or <a>user agent</a> interacts with a <a>push service</a>.
      </p>
    </section>
    <section id="sotd"></section>
    <section class="informative" id="introduction">
      <h2>
        Introduction
      </h2>
      <p>
        The Push API allows a web application to communicate with a <a>user agent</a>
        asynchronously. This allows an <a>application server</a> to provide the <a>user agent</a>
        with time-sensitive information whenever that information becomes known, rather than
        waiting for a user to open the web application.
      </p>
      <p>
        As defined here, <a>push services</a> support delivery of <a>push messages</a> at any time.
      </p>
      <p>
        In particular, a <a>push message</a> will be delivered to the web application even if that
        web application is not currently active in a browser window: this relates to use cases in
        which the user may close the web application, but still benefits from the web application
        being able to be restarted when a <a>push message</a> is received. For example, a <a>push
        message</a> might be used to inform the user of an incoming WebRTC call.
      </p>
      <p>
        A <a>push message</a> can also be sent when the <a>user agent</a> is temporarily offline.
        In support of this, the <a>push service</a> stores messages for the <a>user agent</a> until
        the <a>user agent</a> becomes available. This supports use cases where a web application
        learns of changes that occur while a user is offline and ensures that the <a>user agent</a>
        can be provided with relevant information in a timely fashion. <a>Push messages</a> are
        stored by the <a>push service</a> until the <a>user agent</a> becomes reachable and the
        message can be delivered.
      </p>
      <p>
        The Push API will also ensure reliable delivery of push messages while a <a>user agent</a>
        is actively using a web application, for instance if a user is actively using the web
        application or the web application is in active communication with an <a>application
        server</a> through an active worker, frame, or background window. This is not the primary
        use case for the Push API. A web application might choose to use the Push API for
        infrequent messages to avoid having to maintain constant communications with the
        <a>application server</a>.
      </p>
      <p>
        Push messaging is best suited to occasions where there is not already an active
        communications channel established between <a>user agent</a> and web application. Sending
        <a>push messages</a> requires considerably more resources when compared with more direct
        methods of communication such as [[[fetch]]] or <a data-cite=
        "html/web-sockets.html#network">websockets</a>. <a>Push messages</a> usually have higher
        latency than direct communications and they can also be subject to restrictions on use.
        Most <a>push services</a> limit the size and quantity of <a>push messages</a> that can be
        sent.
      </p>
    </section>
    <section>
      <h2>
        Dependencies
      </h2>
      <p>
        <code><dfn data-cite="ECMASCRIPT#sec-json.parse">JSON.parse</dfn></code> and
        <code><dfn data-cite="ECMASCRIPT#sec-json.stringify">JSON.stringify</dfn></code> are
        defined in [[ECMASCRIPT]].
      </p>
      <p>
        The <dfn>web push protocol</dfn> [[RFC8030]] describes a protocol that enables
        communication between a <a>user agent</a> or <a>application server</a> and a <a>push
        service</a>. Alternative protocols could be used in place of this protocol, but this
        specification assumes the use of this protocol; alternative protocols are expected to
        provide compatible semantics.
      </p>
      <p>
        The <dfn>Content-Encoding</dfn> HTTP header, described in Section 3.1.2.2 of [[RFC7231]],
        indicates the content coding applied to the payload of a <a>push message</a>.
      </p>
    </section>
    <section>
      <h2>
        Concepts
      </h2>
      <section>
        <h2>
          Application server
        </h2>
        <p>
          The term <dfn>application server</dfn> refers to server-side components of a web
          application.
        </p>
      </section>
      <section>
        <h2>
          Push message
        </h2>
        <p>
          A <dfn>push message</dfn> is data sent to a web application from an <a>application
          server</a>.
        </p>
        <p>
          A <a>push message</a> is delivered to the [=service worker registration/active worker=]
          associated with the <a>push subscription</a> to which the message was submitted. If the
          service worker is not currently running, the worker is started to enable delivery.
        </p>
      </section>
      <section>
        <h2>
          Push subscription
        </h2>
        <p>
          A <dfn>push subscription</dfn> is a message delivery context established between the
          <a>user agent</a> and the <a>push service</a> on behalf of a web application. Each
          <a>push subscription</a> is associated with a <a>service worker registration</a> and a
          <a>service worker registration</a> has at most one <a>push subscription</a>.
        </p>
        <p>
          A <a>push subscription</a> has an associated <dfn>push endpoint</dfn>. It MUST be the
          absolute URL exposed by the <a>push service</a> where the <a>application server</a> can
          send <a>push messages</a> to. A <a>push endpoint</a> MUST uniquely identify the <a>push
          subscription</a>.
        </p>
        <p>
          A <a>push subscription</a> MAY have an associated <dfn>subscription expiration
          time</dfn>. When set, it MUST be the time, in milliseconds since 00:00:00 UTC on 1
          January 1970, at which the subscription will be <a>deactivated</a>. The <a>user agent</a>
          SHOULD attempt to <a>refresh</a> the push subscription before the subscription expires.
        </p>
        <p>
          A <a>push subscription</a> has internal slots for a P-256 <a>ECDH</a> key pair and an
          authentication secret in accordance with [[RFC8291]]. These slots MUST be populated when
          creating the <a>push subscription</a>.
        </p>
        <p>
          If the <a>user agent</a> has to change the keys for any reason, it MUST <a>fire the
          "`pushsubscriptionchange`" event</a> with the <a>service worker registration</a>
          associated with the <a>push subscription</a> as <var>registration</var>, a
          <a>PushSubscription</a> instance representing the <a>push subscription</a> having the old
          keys as <var>oldSubscription</var> and a <a>PushSubscription</a> instance representing
          the <a>push subscription</a> having the new keys as <var>newSubscription</var>.
        </p>
        <p>
          To <dfn>create a push subscription</dfn>, given an <a>PushSubscriptionOptions</a> object
          of <var>options</var>, the <a>user agent</a> must run the following steps:
        </p>
        <ol>
          <li>Let <var>subscription</var> be a new <a>push subscription</a>.
          </li>
          <li>Set the `options` attribute of <var>subscription</var> to be a copy of
          <var>options</var>.
          </li>
          <li>Generate a new P-256 <a>ECDH</a> key pair [[ANSI-X9-62]]. Store the private key in an
          internal slot on <var>subscription</var>; this value MUST NOT be made available to
          applications. The public key is also stored in an internal slot and can be retrieved by
          calling the `getKey()` method of the <a>PushSubscription</a> with an argument of
          <a data-link-for="PushEncryptionKeyName">p256dh</a>.
          </li>
          <li>Generate a new authentication secret, which is a sequence of octets as defined in
          [[RFC8291]]. Store the authentication secret in an internal slot on
          <var>subscription</var>. This key can be retrieved by calling the `getKey()` method of
          the <a>PushSubscription</a> with an argument of <a data-link-for="PushEncryptionKeyName">
            auth</a>.
          </li>
          <li>Make a request to the <a>push service</a> to create a new <a>push subscription</a>.
          Include the <a data-link-for="PushSubscriptionOptions">applicationServerKey</a> attribute
          of <var>options</var> when it has been set.
          </li>
          <li>When the request has completed, return <var>subscription</var>.
          </li>
        </ol>
        <section>
          <h2>
            Subscription Refreshes
          </h2>
          <p>
            A <a>user agent</a> or <a>push service</a> MAY choose to <dfn>refresh</dfn> a <a>push
            subscription</a> at any time, for example because it has reached a certain age.
          </p>
          <p>
            When this happens, the <a>user agent</a> MUST run the steps to <a>create a push
            subscription</a> given the <a>PushSubscriptionOptions</a> that were provided for
            creating the current <a>push subscription</a>. The new <a>push subscription</a> MUST
            have a key pair that's different from the original subscription.
          </p>
          <p>
            When successful, <a>user agent</a> then MUST <a>fire the "`pushsubscriptionchange`"
            event</a> with the <a>service worker registration</a> associated with the <a>push
            subscription</a> as <var>registration</var>, a <a>PushSubscription</a> instance
            representing the initial <a>push subscription</a> as <var>oldSubscription</var> and a
            <a>PushSubscription</a> instance representing the new <a>push subscription</a> as
            <var>newSubscription</var>.
          </p>
          <p>
            To allow for time to propagate changes to <a>application servers</a>, a <a>user
            agent</a> MAY continue to accept messages for an old <a>push subscription</a> for a
            brief time after a refresh. Once messages have been received for a refreshed <a>push
            subscription</a>, any old <a>push subscriptions</a> MUST be <a>deactivated</a>.
          </p>
          <p>
            If the <a>user agent</a> is not able to refresh the <a>push subscription</a>, it SHOULD
            periodically retry the refresh. When the <a>push subscription</a> can no longer be
            used, for example because it has expired, the <a>user agent</a> MUST <a>fire the
            "`pushsubscriptionchange`" event</a> with the <a>service worker registration</a>
            associated with the <a>push subscription</a> as <var>registration</var>, a
            <a>PushSubscription</a> instance representing the deactivating <a>push subscription</a>
            as <var>oldSubscription</var> and `null` as the <var>newSubscription</var>.
          </p>
        </section>
        <section>
          <h2>
            Subscription Deactivation
          </h2>
          <p>
            When a <a>push subscription</a> is <dfn data-lt="deactivate">deactivated</dfn>, both
            the <a>user agent</a> and the <a>push service</a> MUST delete any stored copies of its
            details. Subsequent <a>push messages</a> for this <a>push subscription</a> MUST NOT be
            delivered.
          </p>
          <p>
            A <a>push subscription</a> is <a>deactivated</a> when its associated <a>service worker
            registration</a> is unregistered, though a <a>push subscription</a> MAY be
            <a>deactivated</a> earlier.
          </p>
          <p class="note">
            A <a>push subscription</a> is removed when <a>service worker registration</a> is
            cleared.
          </p>
        </section>
      </section>
      <section>
        <h2>
          Push service
        </h2>
        <p>
          The term <dfn data-lt="push services">push service</dfn> refers to a system that allows
          <a>application servers</a> to send <a>push messages</a> to a web application. A push
          service serves the <a>push endpoint</a> or <a data-lt="push endpoints">endpoints</a> for
          the <a>push subscriptions</a> it serves.
        </p>
        <p>
          The <a>user agent</a> connects to the <a>push service</a> used to create <a>push
          subscriptions</a>. <a>User agents</a> MAY limit the choice of <a>push services</a>
          available. Reasons for doing so include performance-related concerns such as service
          availability (including whether services are blocked by firewalls in specific countries,
          or networks at workplaces and the like), reliability, impact on battery lifetime, and
          agreements to steer metadata to, or away from, specific <a>push services</a>.
        </p>
      </section>
      <section>
        <h2>
          Permission
        </h2>
        <p>
          The term <dfn>express permission</dfn> refers to an act by the user, e.g. via user
          interface or host device platform features, via which the user approves the use of the
          Push API by the web application.
        </p>
      </section>
    </section>
    <section>
      <h2>
        Security and privacy considerations
      </h2>
      <p>
        The contents of a <a>push message</a> are encrypted [[RFC8291]]. However, the <a>push
        service</a> is still exposed to the metadata of messages sent by an <a>application
        server</a> to a <a>user agent</a> over a <a>push subscription</a>. This includes the
        timing, frequency and size of messages. Other than changing <a>push services</a>, which
        user agents may disallow, the only known mitigation is to increase the apparent message
        size by padding.
      </p>
      <p>
        There is no guarantee that a <a>push message</a> was sent by an <a>application server</a>
        having the same origin as the web application. The <a>application server</a> is able to
        share the details necessary to use a <a>push subscription</a> with a third party at its own
        discretion.
      </p>
      <p>
        The following requirements are intended to protect the privacy and security of the user as
        far as possible, and subject to meeting that goal, to protect the integrity of the
        <a>application server</a>'s communication with the user.
      </p>
      <p>
        <a>User agents</a> MUST NOT provide Push API access to web applications without the
        <a>express permission</a> of the user. <a>User agents</a> MUST acquire consent for
        permission through a user interface for each call to the `subscribe()` method, unless a
        previous permission grant has been persisted, or a prearranged trust relationship applies.
        Permissions that are preserved beyond the current browsing session MUST be revocable.
      </p>
      <p>
        The Push API may have to wake up the Service Worker associated with the <a>service worker
        registration</a> in order to run the developer-provided event handlers. This can cause
        resource usage, such as network traffic, that the <a>user agent</a> SHOULD attribute to the
        web application that created the <a>push subscription</a>.
      </p>
      <p>
        The <a>user agent</a> MAY consider the <a>PushSubscriptionOptions</a> when acquiring
        permission or determining the permission status.
      </p>
      <p>
        When a permission is revoked, the <a>user agent</a> MAY <a>fire the
        "`pushsubscriptionchange`" event</a> for subscriptions created with that permission, with
        the <a>service worker registration</a> associated with the <a>push subscription</a> as
        <var>registration</var>, a <a>PushSubscription</a> instance representing the <a>push
        subscription</a> as <var>oldSubscription</var>, and `null` as <var>newSubscription</var>.
        The <a>user agent</a> MUST <a>deactivate</a> the affected subscriptions in parallel.
      </p>
      <p>
        When a <a>service worker registration</a> is unregistered, any associated <a>push
        subscription</a> MUST be <a>deactivated</a>.
      </p>
      <p>
        The <a>push endpoint</a> MUST NOT expose information about the user to be derived by actors
        other than the <a>push service</a>, such as the user's device, identity or location. See
        the Privacy Considerations in [[RFC8030]] for the exact requirements.
      </p>
      <p>
        The <a>push endpoint</a> of a <a>deactivated</a> <a>push subscription</a> MUST NOT be
        reused for a new <a>push subscription</a>. This prevents the creation of a persistent
        identifier that the user cannot remove. This also prevents reuse of the details of one
        <a>push subscription</a> to send <a>push messages</a> to another <a>push subscription</a>.
      </p>
      <p>
        <a>User agents</a> MUST implement the Push API to only be available in <a data-cite=
        "secure-contexts#secure-context">secure contexts</a>. This provides better protection for
        the user against man-in-the-middle attacks intended to obtain push subscription data.
        Browsers may ignore this rule for development purposes only.
      </p>
    </section>
    <section class="informative" id="pushframework">
      <h2>
        Push Framework
      </h2>
      <p>
        A <a>push message</a> is sent from an <a>application server</a> to a web application as
        follows:
      </p>
      <ul>
        <li>the <a>application server</a> requests that the <a>push service</a> deliver a <a>push
        message</a> using the [[RFC8030]]. This request uses the <a>push endpoint</a> included in
        the <a>push subscription</a>;
        </li>
        <li>the <a>push service</a> delivers the message to a specific <a>user agent</a>,
        identifying the <a>push endpoint</a> in the message;
        </li>
        <li>the <a>user agent</a> identifies the intended <a>Service Worker</a> and activates it as
        necessary, and delivers the <a>push message</a> to the <a>Service Worker</a>.
        </li>
      </ul>
      <p>
        This overall framework allows <a>application servers</a> to activate a <a>Service
        Worker</a> in response to events at the <a>application server</a>. Information about those
        events can be included in the <a>push message</a>, which allows the web application to
        react appropriately to those events, potentially without needing to initiate network
        requests.
      </p>
      <p>
        The following code and diagram illustrate a hypothetical use of the push API.
      </p>
      <section class="informative">
        <h2>
          Example
        </h2>
        <pre class="example">
          // https://example.com/serviceworker.js
          this.onpush = event =&gt; {
            console.log(event.data);
            // From here we can write the data to IndexedDB, send it to any open
            // windows, display a notification, etc.
          }

          // https://example.com/webapp.js
          // inside an async function...
          try {
            const serviceWorkerRegistration = await navigator.serviceWorker.register(
              "serviceworker.js"
            );
            const pushSubscription = await serviceWorkerRegistration.pushManager.subscribe();
            // The push subscription details needed by the application
            // server are now available, and can be sent to it using,
            // for example, an XMLHttpRequest.
            console.log(pushSubscription.endpoint);
            console.log(pushSubscription.getKey("p256dh"));
            console.log(pushSubscription.getKey("auth"));
          } catch (err) {
            // In a production environment it might make sense to
            // also report information about errors back to the
            // application server.
            console.log(error);
          }
      </pre>
      </section>
      <section class="informative">
        <h2>
          Sequence diagram
        </h2>
        <figure>
          <a href="sequence_diagram.png"><img src="sequence_diagram.png" width="795" height="870"
          alt=
          "Example flow of events for subscription, push message delivery, and unsubscription"></a>
          <figcaption>
            Example flow of events for subscription, push message delivery, and unsubscription
          </figcaption>
        </figure>
      </section>
      <section>
        <h3>
          Push service use
        </h3>
        <p>
          The fields included in the <a>PushSubscription</a> is all the information needed for an
          <a>application server</a> to send a <a>push message</a>. Push services that are
          compatible with the Push API provide a <a>push endpoint</a> that conforms to the <a>web
          push protocol</a>. These parameters and attributes include:
        </p>
        <ul>
          <li>The <a data-lt="PushSubscription.endpoint">push endpoint</a> of a
          <a>PushSubscription</a> is a URL that allows an <a>application server</a> to request
          delivery of a <a>push message</a> to a web application.
          </li>
          <li data-link-for="PushSubscription">The {{getKey()}} method on a <a>PushSubscription</a>
          is used to retrieve keying material used to encrypt and authenticate <a>push
          messages</a>. Each invocation of the function returns a new {{ArrayBuffer}} that contains
          the value of the corresponding key, or `null` if the identified key doesn't exist.
          Passing a value of <a data-link-for="PushEncryptionKeyName">p256dh</a> retrieves a
          <dfn data-lt="ECDH">elliptic curve Diffie-Hellman (ECDH)</dfn> public key associated with
          the <a>push subscription</a>. Passing a value of `auth` returns an authentication secret
          that an application server uses in authentication of its messages. These keys are used by
          the <a>application server</a> to encrypt and authenticate messages for the <a>push
          subscription</a>, as described in [[RFC8291]].
          </li>
        </ul>
      </section>
    </section>
    <section data-dfn-for="ServiceWorkerRegistration">
      <h2>
        Extensions to the `ServiceWorkerRegistration` Interface
      </h2>
      <p>
        The Service Worker specification defines a <code><dfn data-cite=
        "service-workers#serviceworkerregistration">ServiceWorkerRegistration</dfn></code>
        interface [[SERVICE-WORKERS]], which this specification extends.
      </p>
      <pre class="idl" data-cite="service-workers">
        [SecureContext]
        partial interface ServiceWorkerRegistration {
          readonly attribute PushManager pushManager;
        };
      </pre>
      <p>
        The <dfn>pushManager</dfn> attribute exposes a <a>PushManager</a>, which has an associated
        <a>service worker registration</a> represented by the <a>ServiceWorkerRegistration</a> on
        which the attribute is exposed.
      </p>
    </section>
    <section>
      <h2>
        <dfn>PushManager</dfn> interface
      </h2>
      <p>
        The <a>PushManager</a> interface defines the operations to access <a>push services</a>.
      </p>
      <pre class="idl">
        [Exposed=(Window,Worker), SecureContext]
        interface PushManager {
          [SameObject] static readonly attribute FrozenArray&lt;DOMString&gt; supportedContentEncodings;

          Promise&lt;PushSubscription&gt; subscribe(optional PushSubscriptionOptionsInit options = {});
          Promise&lt;PushSubscription?&gt; getSubscription();
          Promise&lt;PushPermissionState&gt; permissionState(optional PushSubscriptionOptionsInit options = {});
        };
      </pre>
      <p>
        The <dfn data-dfn-for="PushManager">supportedContentEncodings</dfn> attribute exposes the
        sequence of supported content codings that can be used to encrypt the payload of a <a>push
        message</a>. A content coding is indicated using the <a>Content-Encoding</a> header field
        when requesting the sending of a <a>push message</a> from the <a>push service</a>.
      </p>
      <p>
        <a>User agents</a> MUST support the `aes128gcm` content coding defined in [[RFC8291]], and
        MAY support content codings defined in previous versions of the draft for compatibility
        reasons.
      </p>
      <p>
        The <dfn data-dfn-for="PushManager">subscribe</dfn> method when invoked MUST run the
        following steps:
      </p>
      <ol>
        <li>Let <var>promise</var> be <a>a new promise</a>.
        </li>
        <li>Return <var>promise</var> and continue the following steps asynchronously.
        </li>
        <li>If the <a>current settings object</a> is not a <a data-cite=
        "secure-contexts#secure-context">secure context</a>, reject <var>promise</var> with a
        {{DOMException}} whose name is "{{SecurityError}}" and terminate these steps.
        </li>
        <li>If the <var>options</var> argument includes a non-null value for the
          <a data-link-for="PushSubscriptionOptions">applicationServerKey</a> attribute, run the
          following substeps:
          <ol>
            <li>If the <var>applicationServerKey</var> is provided as a {{DOMString}}, set its
            value to an {{ArrayBuffer}} containing the sequence of octets that result from decoding
            <var>applicationServerKey</var> using the base64url encoding [[RFC7515]]. If decoding
            fails, reject promise with a {{DOMException}} whose name is "{{InvalidCharacterError}}"
            and terminate these steps.
            </li>
            <li>Ensure that <var>applicationServerKey</var> describes a valid point on the P-256
            curve. If the <var>applicationServerKey</var> value is invalid, reject
            <var>promise</var> with a {{DOMException}} whose name is "<a data-xref-type=
            "exception">InvalidAccessError</a>" and terminate these steps.
            </li>
          </ol>
        </li>
        <li>If the <var>options</var> argument does not include a non-null value for the
        <a data-link-for="PushSubscriptionOptions">applicationServerKey</a> attribute, and the <a>
          push service</a> requires one to be given, reject <var>promise</var> with a
          {{DOMException}} whose name is "{{NotSupportedError}}" and terminate these steps.
        </li>
        <li>Let <var>registration</var> be the <a>PushManager</a>'s associated <a>service worker
        registration</a>.
        </li>
        <li>If <var>registration</var>'s [=service worker registration/active worker=] is null,
        reject <var>promise</var> with a {{DOMException}} whose name is "{{InvalidStateError}}" and
        terminate these steps.
        </li>
        <li>Ask the user whether they allow the web application to receive <a>push messages</a>,
        unless a prearranged trust relationship applies or the user has already granted or denied
        permission explicitly for this web application. Note that a <a>user agent</a> that needs to
        request permission might be unable to do so if <a data-link-for="PushManager">subscribe</a>
        is invoked from a service worker, in which case permission will be denied automatically.
        </li>
        <li>If not granted, reject <var>promise</var> with a {{DOMException}} whose name is
        "{{NotAllowedError}}" and terminate these steps.
        </li>
        <li>If the <a>Service Worker</a> is already subscribed, run the following substeps:
          <ol>
            <li>Retrieve the <a>push subscription</a> associated with the <a>Service Worker</a>.
            </li>
            <li>If there is an error, reject <var>promise</var> with a {{DOMException}} whose name
            is "{{AbortError}}" and terminate these steps.
            </li>
            <li>Let <var>subscription</var> be the retrieved subscription.
            </li>
            <li>Compare the <var>options</var> argument with the `options` attribute of
            <var>subscription</var>. If any attribute on <var>options</var> contains a different
            value to that stored for <var>subscription</var>, then reject <var>promise</var> with
            an {{InvalidStateError}} and terminate these steps. The contents of {{BufferSource}}
            values are compared for equality rather than <a href=
            "https://tc39.github.io/ecma262/#sec-reference-specification-type">references</a>.
            </li>
            <li>When the request has been completed, resolve <var>promise</var> with
            <var>subscription</var>.
            </li>
          </ol>
        </li>
        <li>Let <var>subscription</var> be the result of running the <a>create a push
        subscription</a> steps given <var>options</var>.
        </li>
        <li>If there is an error, reject <var>promise</var> with a {{DOMException}} whose name is
        "{{AbortError}}" and terminate these steps.
        </li>
        <li>Resolve <var>promise</var> with a <a>PushSubscription</a> providing the details of the
        new <var>subscription</var>.
        </li>
      </ol>
      <p>
        The <dfn data-dfn-for="PushManager">getSubscription</dfn> method when invoked MUST run the
        following steps:
      </p>
      <ol>
        <li>Let <var>promise</var> be <a>a new promise</a>.
        </li>
        <li>Return <var>promise</var> and continue the following steps asynchronously.
        </li>
        <li>If the <a>Service Worker</a> is not subscribed, resolve <var>promise</var> with null.
        </li>
        <li>Retrieve the <a>push subscription</a> associated with the <a>Service Worker</a>.
        </li>
        <li>If there is an error, reject <var>promise</var> with a {{DOMException}} whose name is
        "{{AbortError}}" and terminate these steps.
        </li>
        <li>When the request has been completed, resolve <var>promise</var> with a
        <a>PushSubscription</a> providing the details of the retrieved <a>push subscription</a>.
        </li>
      </ol>
      <p>
        The <dfn data-dfn-for="PushManager">permissionState</dfn> method when invoked MUST run the
        following steps:
      </p>
      <ol>
        <li>Let <var>promise</var> be <a>a new promise</a>.
        </li>
        <li>Return <var>promise</var> and continue the following steps asynchronously.
        </li>
        <li>Retrieve the push permission status (<a>PushPermissionState</a>) of the requesting web
        application.
        </li>
        <li>If there is an error, reject <var>promise</var> with no arguments and terminate these
        steps.
        </li>
        <li>When the request has been completed, resolve <var>promise</var> with
        <a>PushPermissionState</a> providing the push permission status.
        </li>
      </ol>
      <p>
        Permission to use the push service can be persistent, that is, it does not need to be
        reconfirmed for subsequent subscriptions if a valid permission exists.
      </p>
      <p>
        If there is a need to ask for permission, it needs to be done by invoking the <a data-lt=
        "PushManager.subscribe">subscribe</a> method.
      </p>
      <section data-dfn-for="PushSubscriptionOptions" data-link-for="PushSubscriptionOptions">
        <h2>
          <dfn>PushSubscriptionOptions</dfn> Interface
        </h2>
        <pre class="idl">
          [Exposed=(Window,Worker), SecureContext]
          interface PushSubscriptionOptions {
            readonly attribute boolean userVisibleOnly;
            [SameObject] readonly attribute ArrayBuffer? applicationServerKey;
          };
        </pre>
        <p>
          The <dfn>userVisibleOnly</dfn> attribute, when getting, returns the value it was
          initialized with.
        </p>
        <p>
          The <dfn>applicationServerKey</dfn> attribute, when getting, returns the value it was
          initialized with.
        </p>
        <p>
          If present, the value of <a data-link-for=
          "PushSubscriptionOptions">applicationServerKey</a> MUST include a point on the P-256
          elliptic curve [[DSS]], encoded in the uncompressed form described in [[ANSI-X9-62]]
          Annex A (that is, 65 octets, starting with an 0x04 octet). When provided as a
          {{DOMString}}, the value MUST be encoded using the base64url encoding [[RFC7515]].
        </p>
        <p>
          User agents MAY reject a subscription attempt when <a>applicationServerKey</a> is not
          present and the <a>push service</a> requires one for operational reasons.
        </p>
        <p>
          The <a data-link-for="PushSubscriptionOptions">applicationServerKey</a> MUST be a
          different value to the one used for message encryption [[RFC8291]].
        </p>
      </section>
      <section data-dfn-for="PushSubscriptionOptionsInit" data-link-for=
      "PushSubscriptionOptionsInit">
        <h3>
          <dfn>PushSubscriptionOptionsInit</dfn> dictionary
        </h3>
        <pre class="idl">
          dictionary PushSubscriptionOptionsInit {
            boolean userVisibleOnly = false;
            (BufferSource or DOMString)? applicationServerKey = null;
          };
        </pre>
        <p>
          The <dfn>userVisibleOnly</dfn> member, when set to `true`, indicates that the <a>push
          subscription</a> will only be used for <a>push messages</a> whose effect is made visible
          to the user, for example by displaying a Web Notification. [[NOTIFICATIONS]]
        </p>
        <p>
          A <a>PushSubscriptionOptionsInit</a> represents additional options associated with a
          <a>push subscription</a>. The <a>user agent</a> MAY consider these options when
          requesting <a>express permission</a> from the user. When an option is considered, the
          <a>user agent</a> SHOULD enforce it on incoming <a>push messages</a>.
        </p>
        <p>
          These options are optional, and <a>user agents</a> MAY choose to support only a subset of
          them. A <a>user agent</a> MUST NOT expose options that it does not support.
        </p>
        <p>
          Once set, options for a <a>push subscription</a> cannot change. A pre-existing <a>push
          subscription</a> can be unsubscribed, via <a data-link-for=
          "PushSubscription">unsubscribe()</a>, to create a <a>push subscription</a> with new
          options.
        </p>
        <p>
          The <dfn>applicationServerKey</dfn> member is used by the <a>user agent</a> when
          establishing a <a>push subscription</a> with a <a>push service</a>. The
          <a>applicationServerKey</a> option includes an elliptic curve public key for an
          <a>application server</a>. This is the key that the <a>application server</a> will use to
          authenticate itself when sending <a>push messages</a> to this <a>push subscription</a> as
          defined in [[RFC8292]]; the <a>push service</a> will reject any <a>push message</a>
          unless the corresponding private key is used to generate an authentication token.
        </p>
      </section>
    </section>
    <section data-dfn-for="PushSubscription" data-link-for="PushSubscription">
      <h2>
        <dfn>PushSubscription</dfn> interface
      </h2>
      <p>
        A <a>PushSubscription</a> object represents a <a>push subscription</a>.
      </p>
      <pre class="idl">
        [Exposed=(Window,Worker), SecureContext]
        interface PushSubscription {
          readonly attribute USVString endpoint;
          readonly attribute DOMTimeStamp? expirationTime;
          [SameObject] readonly attribute PushSubscriptionOptions options;
          ArrayBuffer? getKey(PushEncryptionKeyName name);
          Promise&lt;boolean&gt; unsubscribe();

          PushSubscriptionJSON toJSON();
        };

        dictionary PushSubscriptionJSON {
          USVString endpoint;
          DOMTimeStamp? expirationTime;
          record&lt;DOMString, USVString&gt; keys;
        };
      </pre>
      <p>
        When getting the <dfn>endpoint</dfn> attribute, the <a>user agent</a> MUST return the
        <a>push endpoint</a> associated with the <a>push subscription</a>. The <a>user agent</a>
        MUST use a serialization method that does not contain input-dependent branchs (that is, one
        that is constant time).
      </p>
      <p>
        When getting the <dfn>expirationTime</dfn> attribute, the <a>user agent</a> MUST return the
        <a>subscription expiration time</a> associated with the <a>push subscription</a> if there
        is one, or `null` otherwise.
      </p>
      <p>
        When getting the <dfn>options</dfn> attribute, the <a>user agent</a> MUST return a
        <a>PushSubscriptionOptions</a> object representing the options associated with the <a>push
        subscription</a>.
      </p>
      <p>
        The <dfn>getKey()</dfn> method retrieves keying material that can be used for encrypting
        and authenticating messages. When <a>getKey()</a> is invoked the following process is
        followed:
      </p>
      <ol data-link-for="PushEncryptionKeyName">
        <li>Find the internal slot corresponding to the key named by the `name` argument.
        </li>
        <li>If a slot was not found, return `null`.
        </li>
        <li>Initialize a variable <var>key</var> with a newly instantiated {{ArrayBuffer}}
        instance.
        </li>
        <li>If the internal slot contains an asymmetric key pair, set the contents of
        <var>key</var> to the serialized value of the public key from the key pair. This uses the
        serialization format described in the specification that defines the name. For example,
        [[RFC8291]] specifies that the <a>p256dh</a> public key is encoded using the uncompressed
        format defined in [[ANSI-X9-62]] Annex A (that is, a 65 octet sequence that starts with a
        0x04 octet).
        </li>
        <li>Otherwise, if the internal slot contains a symmetric key, set the contents of
        <var>key</var> to a copy of the value from the internal slot. For example, the `auth`
        parameter contains an octet sequence used by the <a>user agent</a> to authenticate messages
        sent by an <a>application server</a>.
        </li>
        <li>Return <var>key</var>.
        </li>
      </ol>
      <p data-link-for="PushEncryptionKeyName">
        Keys named <a>p256dh</a> and <a>auth</a> MUST be supported, and their values MUST
        correspond to those necessary for the user agent to decrypt received push messages in
        accordance with [[RFC8291]].
      </p>
      <p>
        The <dfn data-lt="unsubscribed">unsubscribe()</dfn> method when invoked MUST run the
        following steps:
      </p>
      <ol>
        <li>Let <var>promise</var> be <a>a new promise</a>.
        </li>
        <li>Return <var>promise</var> and continue the following steps asynchronously.
        </li>
        <li>If the <a>push subscription</a> has already been <a>deactivated</a>, resolve
        <var>promise</var> with `false` and terminate these steps.
        </li>
        <li>Run the following step in parallel:
          <ol>
            <li>
              <a>Deactivate</a> the <a>push subscription</a>. The <a>user agent</a> MUST NOT
              deliver any further <a>push messages</a> for the <a>push subscription</a>.
              <p>
                If the <a>user agent</a> failed to request the <a>push service</a> to
                <a>deactivate</a> the <a>push subscription</a>, for example because of network
                failures, it SHOULD retry the request to the <a>push service</a> for a reasonable
                amount of time.
              </p>
            </li>
          </ol>
        </li>
        <li>Resolve <var>promise</var> with `true`.
        </li>
      </ol>
      <p>
        The <dfn>toJSON()</dfn> method when invoked MUST run the following steps:
      </p>
      <ol>
        <li>Let <var>json</var> be a new `PushSubscriptionJSON` dictionary.
        </li>
        <li>Set <var>json</var>["endpoint"] to the result of <a data-lt="get the underlying value">
          getting the underlying value</a> of the <a data-link-for="PushSubscription">endpoint</a>
          attribute given this <a>PushSubscription</a> object.
        </li>
        <li>Set <var>json</var>["expirationTime"] to the result of <a data-lt=
        "get the underlying value">getting the underlying value</a> of the <a data-link-for=
        "PushSubscription">expirationTime</a> attribute given this <a>PushSubscription</a> object.
        </li>
        <li>Let <var>keys</var> be a new empty instance of `record&lt;DOMString, USVString&gt;` .
        </li>
        <li>For each identifier <var>i</var> corresponding to keys in internal slots on the
        <a>PushSubscription</a>, ordered by the name of the key:
          <ol>
            <li>If the internal slot corresponds to an asymmetric key pair, let <var>b</var> be the
            encoded value of the public key corresponding to the key name <var>i</var>, using the
            encoding defined for the key name (see <a data-lt=
            "PushSubscription.getKey">getKey</a>).
            </li>
            <li>Otherwise, let <var>b</var> be the value as returned by <a data-lt=
            "PushSubscription.getKey">getKey</a>.
            </li>
            <li>Let <var>s</var> be the URL-safe base64 encoding without padding [[RFC4648]] of
            <var>b</var> as a <a data-xref-type="_IDL_">USVString</a>. The <a>user agent</a> MUST
            use a serialization method that does not branch based on the value of <var>b</var>.
            </li>
            <li>Set <var>keys</var>[<var>i</var>] to <var>s</var>.
            </li>
          </ol>
        </li>
        <li>Set <var>json</var>["keys"] to <var>keys</var>.
        </li>
        <li>Return <var>json</var>.
        </li>
      </ol>
      <p>
        A <dfn>PushSubscriptionJSON</dfn> dictionary represents the <a>JSON type</a> of a
        <a>PushSubscription</a>. In ECMAScript this can be converted into a JSON string through the
        <a>JSON.stringify</a> function.
      </p>
      <p>
        The <dfn data-dfn-for="PushSubscriptionJSON">endpoint</dfn> contains the <a data-lt=
        "get the underlying value">underlying value</a> of the <a data-link-for=
        "PushSubscription">endpoint</a> attribute.
      </p>
      <p>
        The <dfn data-dfn-for="PushSubscriptionJSON">expirationTime</dfn> contains the <a data-lt=
        "get the underlying value">underlying value</a> of the <a data-link-for=
        "PushSubscription">expirationTime</a> attribute.
      </p>
      <p>
        The <dfn data-dfn-for="PushSubscriptionJSON">keys</dfn> record contains an entry for each
        of the supported <a>PushEncryptionKeyName</a> entries to the URL-safe base64 encoded
        representation [[RFC4648]] of its value.
      </p>
      <p>
        Note that the options to a <a>PushSubscription</a> are not serialized.
      </p>
      <section data-dfn-for="PushEncryptionKeyName">
        <h2>
          <dfn>PushEncryptionKeyName</dfn> enumeration
        </h2>
        <p>
          Encryption keys used for <a>push message</a> encryption are provided to a web application
          through the <a data-link-for="PushSubscription">getKey</a> method or the serializer of
          <a>PushSubscription</a>. Each key is named using a value from the
          <a>PushEncryptionKeyName</a> enumeration.
        </p>
        <pre class="idl">
          enum PushEncryptionKeyName {
            "p256dh",
            "auth"
          };
        </pre>
        <p>
          The <dfn>p256dh</dfn> value is used to retrieve the P-256 ECDH Diffie-Hellman public key
          described in [[RFC8291]].
        </p>
        <p>
          The <dfn>auth</dfn> value is used to retrieve the authentication secret described in
          [[RFC8291]].
        </p>
      </section>
    </section>
    <section data-dfn-for="PushMessageData">
      <h2>
        <dfn>PushMessageData</dfn> interface
      </h2>
      <pre class="idl" data-cite="FILEAPI">
        [Exposed=ServiceWorker, SecureContext]
        interface PushMessageData {
          ArrayBuffer arrayBuffer();
          Blob blob();
          any json();
          USVString text();
        };
      </pre>
      <p>
        <a>PushMessageData</a> objects have an associated <dfn>bytes</dfn> (a byte sequence) set on
        creation, which is `null` if there was no data in the <a>push message</a>.
      </p>
      <p>
        The <dfn>arrayBuffer()</dfn> method, when invoked, MUST return an {{ArrayBuffer}} whose
        contents are <var>bytes</var>. Exceptions thrown during the creation of the {{ArrayBuffer}}
        object are re-thrown.
      </p>
      <p>
        The <dfn>blob()</dfn> method, when invoked, MUST return a {{Blob}} whose contents are
        <var>bytes</var> and <var>type</var> is not provided.
      </p>
      <p data-cite="encoding">
        The <dfn>json()</dfn> method, when invoked, MUST return the result of invoking the initial
        value of <a>JSON.parse</a> with the result of running <a>utf-8 decode</a> on
        <var>bytes</var> as argument. Re-throw any exceptions thrown by <a>JSON.parse</a>.
      </p>
      <p data-cite="encoding">
        The <dfn>text</dfn> method, when invoked, MUST return the result of running <a>utf-8
        decode</a> on <var>bytes</var>.
      </p>
      <p>
        To <dfn>extract a byte sequence</dfn> from <var>object</var>, run these steps:
      </p>
      <ol>
        <li>Let <var>bytes</var> be an empty byte sequence.
        </li>
        <li>Switch on <var>object</var>'s type:
          <dl data-cite="WebIDL">
            <dt>
              {{BufferSource}}
            </dt>
            <dd>
              Set <var>bytes</var> to a copy of <var>object</var>'s contents.
            </dd>
            <dt>
              {{USVString}}
            </dt>
            <dd data-cite="encoding">
              Set <var>bytes</var> to the result of running <a>utf-8 encode</a> on
              <var>object</var>.
            </dd>
          </dl>
        </li>
        <li>Return <var>bytes</var>.
        </li>
      </ol>
    </section>
    <section>
      <h2>
        Events
      </h2>
      <section data-dfn-for="ServiceWorkerGlobalScope">
        <h2>
          Extensions to the `ServiceWorkerGlobalScope` interface
        </h2>
        <p>
          The Service Worker specification defines a <dfn data-cite=
          "service-workers#serviceworkerglobalscope">ServiceWorkerGlobalScope</dfn> interface
          [[SERVICE-WORKERS]], which this specification extends.
        </p>
        <pre class="idl" data-cite="HTML">
          [Exposed=ServiceWorker, SecureContext]
          partial interface ServiceWorkerGlobalScope {
            attribute EventHandler onpush;
            attribute EventHandler onpushsubscriptionchange;
          };
        </pre>
        <p>
          The <dfn>onpush</dfn> attribute is an <a>event handler IDL attribute</a> whose
          corresponding <a>event handler event type</a> is "`push`". The "`push`" event indicates
          that a <a>push message</a> has been received for a <a>push subscription</a>.
        </p>
        <p>
          The <dfn>onpushsubscriptionchange</dfn> attribute is an <a>event handler IDL
          attribute</a> whose corresponding <a>event handler event type</a> is
          "`pushsubscriptionchange`".
        </p>
      </section>
      <section data-dfn-for="PushEvent">
        <h2>
          <dfn>PushEvent</dfn> Interface
        </h2>
        <pre class="idl" data-cite="service-workers">
            [Constructor(DOMString type, optional PushEventInit eventInitDict = {}), Exposed=ServiceWorker, SecureContext]
            interface PushEvent : ExtendableEvent {
              readonly attribute PushMessageData? data;
            };
          </pre>
        <p>
          When a constructor of the <a>PushEvent</a> interface, or of an interface that inherits
          from the <a>PushEvent</a> interface, is invoked, the usual <a>event constructing
          steps</a> are extended to include the following steps:
        </p>
        <ol>
          <li>If <var>eventInitDict</var>'s `data` member is not present, set the `data` attribute
          of the event to `null` and terminate these steps.
          </li>
          <li>Set <var>b</var> to the result of <a data-lt="extract a byte sequence">extracting a
          byte sequence</a> from the "`data`" member of <var>eventInitDict</var>.
          </li>
          <li>Set the `data` attribute of the event to a new <a>PushMessageData</a> instance with
          `bytes` set to <var>b</var>.
          </li>
        </ol>
        <p>
          The <dfn>data</dfn>, when getting, returns the value it was initialized with.
        </p>
      </section>
      <section data-dfn-for="PushEventInit" data-link-for="PushEventInit">
        <h2>
          <dfn>PushEventInit</dfn>
        </h2>
        <pre class="idl" data-cite="service-workers">
            typedef (BufferSource or USVString) PushMessageDataInit;

            dictionary PushEventInit : ExtendableEventInit {
              PushMessageDataInit data;
            };
          </pre>
        <p>
          The <dfn>data</dfn> member contains the data included in the <a>push message</a> when
          included and the <a>user agent</a> verified its authenticity. The value will be set to
          `null` in all other cases.
        </p>
      </section>
      <section>
        <h2>
          Receiving a <a>Push Message</a>
        </h2>
        <p>
          When the <a>user agent</a> receives a <a>push message</a> from the <a>push service</a>,
          it MUST run the following steps.
        </p>
        <ol>
          <li>Let <var>registration</var> be the <a>service worker registration</a> corresponding
          to the <a>push message</a>.
          </li>
          <li>If <var>registration</var> is not found, abort these steps.
          </li>
          <li>Let <var>subscription</var> be the active <a>push subscription</a> for
          <var>registration</var>.
          </li>
          <li>Initialize <var>data</var> to a value of `null`.
          </li>
          <li>If the <a>push message</a> contains a payload, perform the following steps:
            <ol>
              <li>Decrypt the <a>push message</a> using the private key from the key pair
              associated with <var>subscription</var> and the process described in [[RFC8291]].
              This produces the plain text of the message.
              </li>
              <li>If the <a>push message</a> could not be decrypted for any reason, perform the
              following steps:
                <ol>
                  <li>Acknowledge the receipt of the <a>push message</a> according to [[RFC8030]].
                  Though the message was not successfully received and processed, this prevents the
                  push service from attempting to retransmit the message; a badly encrypted message
                  is not recoverable.
                  </li>
                  <li>Discard the <a>push message</a>.
                  </li>
                  <li>Terminate this process.
                  </li>
                </ol>A `push` event MUST NOT be fired for a <a>push message</a> that was not
                successfully decrypted using the key pair associated with the <a>push
                subscription</a>.
              </li>
              <li>Let <var>data</var> be a new <a>PushMessageData</a> instance with the decrypted
              plain text of the <a>push message</a>.
              </li>
            </ol>
          </li>
          <li>
            <p>
              <a>Handle functional event</a> "`push`" using <a>PushEvent</a> on
              <var>registration</var> with the following properties:
            </p>
            <dl>
              <dt>
                `data`
              </dt>
              <dd>
                <var>data</var>
              </dd>
            </dl>
            <p>
              Then run the following steps in parallel, with <var>dispatchedEvent</var>:
            </p>
            <ol>
              <li>Wait for all of the promises in the [=ExtendableEvent/extend lifetime promises=]
              of <var>dispatchedEvent</var> to resolve.
              </li>
              <li>If all the promises resolve successfully, acknowledge the receipt of the <a>push
              message</a> according to [[RFC8030]] and abort these steps.
              </li>
              <li>
                <p>
                  If the same <a>push message</a> has been delivered to a <a>service worker
                  registration</a> multiple times unsuccessfully, acknowledge the receipt of the
                  <a>push message</a> according to [[RFC8030]].
                </p>
                <p>
                  Acknowledging the <a>push message</a> causes the <a>push service</a> to stop
                  delivering the message and to report success to the <a>application server</a>.
                  This prevents the same <a>push message</a> from being retried by the <a>push
                  service</a> indefinitely.
                </p>
                <p>
                  Acknowledging also means that an <a>application server</a> could incorrectly
                  receive a delivery receipt indicating successful delivery of the <a>push
                  message</a>. Therefore, multiple rejections SHOULD be permitted before
                  acknowledging; allowing at least three attempts is recommended.
                </p>
              </li>
            </ol>
          </li>
        </ol>
      </section>
      <section>
        <h2>
          The <dfn>pushsubscriptionchange</dfn> Event
        </h2>
        <p>
          The <a>pushsubscriptionchange</a> event indicates a change in a <a>push subscription</a>
          that was triggered outside of the application's control, for example because it has been
          refreshed, revoked or lost.
        </p>
        <p>
          To <dfn>fire the "`pushsubscriptionchange`" event</dfn> given a <a>service worker
          registration</a> of <var>registration</var>, <var>newSubscription</var> and
          <var>oldSubscription</var>, the <a>user agent</a> must <a>handle functional event</a>
          "`pushsubscriptionchange`" using <a>PushSubscriptionChangeEvent</a> on
          <var>registration</var> with the following properties:
        </p>
        <dl>
          <dt>
            `newSubscription`
          </dt>
          <dd>
            <var>newSubscription</var>
          </dd>
          <dt>
            `oldSubscription`
          </dt>
          <dd>
            <var>oldSubscription</var>
          </dd>
        </dl>
        <p class="note">
          Consider using a more reliable synchronization mechanism such as [[WEB-BACKGROUND-SYNC]]
          when sending the details of the new <a>push subscription</a> to your <a>application
          server</a>. The user might be subject to unreliable network conditions that could cause a
          fetch to fail.
        </p>
        <section data-dfn-for="PushSubscriptionChangeEvent">
          <h2>
            <dfn>PushSubscriptionChangeEvent</dfn> Interface
          </h2>
          <pre class="idl" data-cite="service-workers">
            [Constructor(DOMString type, optional PushSubscriptionChangeEventInit eventInitDict = {}), Exposed=ServiceWorker, SecureContext]
            interface PushSubscriptionChangeEvent : ExtendableEvent {
              readonly attribute PushSubscription? newSubscription;
              readonly attribute PushSubscription? oldSubscription;
            };
          </pre>
          <p>
            The <dfn>newSubscription</dfn> attribute, when getting, returns the value it was
            initialized to.
          </p>
          <p>
            The <dfn>oldSubscription</dfn> attribute, when getting, returns the value it was
            initialized to.
          </p>
        </section>
        <section data-dfn-for="PushSubscriptionChangeEventInit">
          <h2>
            <dfn>PushSubscriptionChangeEventInit</dfn> Interface
          </h2>
          <pre class="idl" data-cite="service-workers">
              dictionary PushSubscriptionChangeEventInit : ExtendableEventInit {
                PushSubscription newSubscription = null;
                PushSubscription oldSubscription = null;
              };
            </pre>
          <p>
            The <dfn>newSubscription</dfn> member details the <a>push subscription</a> that is
            valid per invocation of the <a>pushsubscriptionchange</a> event. The value will be
            `null` when no new <a>push subscription</a> could be established, for example because
            the web application has lost <a>express permission</a>.
          </p>
          <p>
            The <dfn>oldSubscription</dfn> member details the <a>push subscription</a> that SHOULD
            NOT be used anymore. The value will be `null` when the <a>user agent</a> is not able to
            provide the full set of details, for example because of partial database corruption.
          </p>
        </section>
      </section>
    </section>
    <section data-dfn-for="PushPermissionState">
      <h2>
        <dfn>PushPermissionState</dfn> Enumeration
      </h2>
      <pre class="idl">
        enum PushPermissionState {
          "denied",
          "granted",
          "prompt",
        };
      </pre>
      <table class="simple">
        <tr>
          <th>
            Enumeration
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            <dfn>granted</dfn>
          </td>
          <td>
            The web application has permission to use the Push API.
          </td>
        </tr>
        <tr>
          <td>
            <dfn>denied</dfn>
          </td>
          <td>
            The web application has been denied permission to use the Push API.
          </td>
        </tr>
        <tr>
          <td>
            <dfn>prompt</dfn>
          </td>
          <td>
            The web application needs to ask for permission in order to use the Push API.
          </td>
        </tr>
      </table>
    </section>
    <section id="conformance">
      <p>
        This specification defines conformance criteria that apply to a single product: the
        <dfn data-lt="agents">user agent</dfn> that implements the interfaces that it contains.
      </p>
    </section>
    <section class="appendix" id="idl-index"></section>
    <section class="appendix">
      <h2>
        Acknowledgements
      </h2>
      <p>
        The editors would like to express their gratitude to the Mozilla and TelefÃ³nica Digital
        teams implementing the Firefox OS Push message solution, as well as to the following people
        who provided significant technical input to this document: Antonio Amaya, Miguel GarcÃ­a
        Arribas, Ben Bangert, Kit Cambridge, JosÃ© Manuel Cantera, JR Conlin, Albert Crespell, Matt
        Gaunt, Phil Jenvey, Guillermo LÃ³pez, Nikhil Marathe, John Mellor, PÄ±nar Ãzlen, Fernando R.
        Sela, Shijun Sun and Doug Turner.
      </p>
    </section>
  </body>
</html>
