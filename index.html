<!DOCTYPE html>
<html>
  <head>
    <title>
      Push API
    </title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove'>
    </script>
    <script class="remove">
    // (this is to make tidy happy)
      // See http://www.w3.org/respec/ for ReSpec documentation.
      var respecConfig = {
          specStatus: "ED",
          shortName: "push-api",

          previousPublishDate: "2013-08-15",
          previousMaturity: "WD",
          edDraftURI: "https://w3c.github.io/push-api/",

          editors: [
            {
              name: "Michaël van Ouwerkerk",
              company: "Google",
              companyURL: "https://www.google.com/",
              w3cid: "67729"
            },
            {
              name: "Martin Thomson",
              company: "Mozilla Foundation",
              companyURL: "http://www.mozilla.org/",
              w3cid: "68503"
            },
            {
              name: "Bryan Sullivan",
              company: "AT&T",
              companyURL: "http://www.att.com/",
              note: "until <time>2015-05-01<\u002ftime>",
              w3cid: "41539"
            },
            {
              name: "Eduardo Fullea",
              company: "Telefonica",
              companyURL: "http://www.telefonica.com/",
              note: "until <time>2015-05-01<\u002ftime>",
              w3cid: "53513"
            }
          ],

          wg: "Web Platform Working Group",
          wgURI: "http://www.w3.org/WebPlatform/WG/",
          license: "w3c-software-doc",
          wgPublicList: "public-webapps",
          subjectPrefix: "[Push API]",

          // This is important for Rec-track documents, do not copy a patent URI
          // from a random document unless you know what you're doing. If in
          // doubt ask your friendly neighbourhood Team Contact.
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/83482/status",

          noLegacyStyle: true,

          otherLinks: [
            {
              key: "Participate",
              data: [
                {
                  value: "Mailing list",
                  href: "http://lists.w3.org/Archives/Public/public-webapps/"
                },
                {
                  value: "Browse open issues",
                  href: "https://github.com/w3c/push-api/issues"
                },
                {
                  value: "File a bug",
                  href: "https://github.com/w3c/push-api/issues/new"
                },
              ]
            },
          ],

          localBiblio: {
            "NOTIFICATIONS": {
              title: "Notifications API",
              href: "https://notifications.spec.whatwg.org/",
              authors: [
                "Anne van Kesteren",
              ],
              status: "Living Standard",
              publisher: "WHATWG"
            },
            "WEBPUSH-PROTOCOL": {
              title: "The Web Push Protocol",
              href: "https://tools.ietf.org/html/draft-ietf-webpush-protocol",
              authors: [
                "Martin Thomson",
                "Brian Raymor",
              ],
              status: "Internet-Draft",
              publisher: "IETF"
            },
            "WEBPUSH-ENCRYPTION": {
              title: "Message Encryption for Web Push",
              href: "https://tools.ietf.org/html/draft-ietf-webpush-encryption",
              authors: [
                "Martin Thomson",
              ],
              status: "Internet-Draft",
              publisher: "IETF"
            },
            "X9.62": {
              title: "Public Key Cryptography for the Financial Services Industry, The Elliptic Curve Digital Signature Algorithm (ECDSA)",
              status: "ANS X9.62–2005",
              publisher: "ANSI"
            }
          }
      };
    </script>
  </head>
  <body>
    <section id="abstract">
      <p>
        The <cite>Push API</cite> enables sending of a <a>push message</a> to a <a>webapp</a> via a
        <a>push service</a>. An <a>application server</a> can send a <a>push message</a> at any
        time, even when a <a>webapp</a> or <a>user agent</a> is inactive. The <a>push service</a>
        ensures reliable and efficient delivery to the <a>user agent</a>. <a>Push messages</a> are
        delivered to a <a>Service Worker</a> that runs in the origin of the <a>webapp</a>, which
        can use the information in the message to update local state or display a notification to
        the user.
      </p>
      <p>
        This specification is designed for use with the <a>web push protocol</a>, which describes
        how an <a>application server</a> or <a>user agent</a> interacts with a <a>push service</a>.
      </p>
    </section>
    <section id='sotd'></section>
    <section class='informative' id="introduction">
      <h2>
        Introduction
      </h2>
      <p>
        As defined here, <a>push services</a> support delivery of <a>application server</a>
        messages in the following contexts and related use cases:
      </p>
      <ul>
        <li>the user is actively involved in the use of a <a>webapp</a>: this relates to any normal
        use case in which a <a>webapp</a> user may benefit from <a>push messages</a> while the user
        is actively using the <a>webapp</a>
        </li>
        <li>the user is not actively involved in the use of a <a>webapp</a>, but the <a>webapp</a>
        is active in a window of the browser or executing as a web worker: this relates to use
        cases such as social networking, messaging, web feed readers, etc in which the user may not
        be actively using a <a>webapp</a> but still benefits from <a>push messages</a> being sent
        to (or via) the <a>webapp</a>, to keep the user up-to-date
        </li>
        <li>the <a>webapp</a> is not currently active in a browser window: this relates to use
        cases in which the user may close the <a>webapp</a>, but still benefits from the
        <a>webapp</a> being able to be restarted when a <a>push message</a> is received, e.g. the
        WebRTC use case in which an incoming call can invoke the WebRTC <a>webapp</a>
        </li>
        <li>multiple <a>webapps</a> are running, but <a>push messages</a> are delivered only to the
        <a>webapp</a> that requested them, e.g. any normal use case in which multiple
        <a>webapps</a> are active in the browser and utilizing <a>push services</a>
        </li>
        <li>multiple instances of the same <a>webapp</a> are active in the browser, and <a>push
        messages</a> specific to each instance of the <a>webapp</a> are delivered only to the
        specific instance, e.g. when a mail <a>webapp</a> is active in two windows using different
        mail accounts
        </li>
        <li>multiple instances of the same <a>webapp</a> are active in different browsers, and push
        messages are delivered to a set of instances of the <a>webapp</a>, e.g. when a mail
        <a>webapp</a> is active in two browsers using the same email account
        </li>
        <li>multiple instances of the same <a>webapp</a> are active in different browsers, and push
        messages are delivered to all instances of the <a>webapp</a>, e.g. when a message is to be
        broadcasted to all users of the <a>webapp</a>
        </li>
        <li>the <a>user agent</a> is temporarily offline: this case depends on the <a>push
        service</a> providing reliable message delivery and supports use cases where a
        <a>webapp</a> learns of changes that occur while offline in a timely fashion.
        </li>
      </ul>
    </section>
    <section id="conformance">
      <p>
        This specification defines conformance criteria that apply to a single product: the
        <dfn data-lt="user agent|user agents">user agent</dfn> that implements the interfaces that
        it contains.
      </p>
      <p>
        Implementations that use ECMAScript to implement the APIs defined in this specification
        MUST implement them in a manner consistent with the ECMAScript Bindings defined in the Web
        IDL specification [[!WEBIDL]].
      </p>
    </section>
    <section>
      <h2>
        Dependencies
      </h2>
      <p>
        The terms <dfn><a href="http://www.w3.org/TR/html5/webappapis.html#event-handlers">event
        handler</a></dfn>, <dfn><a href=
        "http://www.w3.org/TR/html5/webappapis.html#event-handler-event-type">event handler event
        type</a></dfn>, <dfn><a href=
        "http://www.w3.org/TR/html5/webappapis.html#queue-a-task">queue a task</a></dfn>,
        <dfn><a href=
        "http://www.w3.org/TR/html5/infrastructure.html#concept-events-trusted">trusted
        event</a></dfn>, and <dfn><a href=
        "http://www.w3.org/TR/html5/webappapis.html#fire-a-simple-event">fire a simple
        event</a></dfn> are defined in [[!HTML5]].
      </p>
      <p>
        <code><a href=
        'http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects'><dfn>Promise</dfn></a></code>,
        and <code><a href=
        "https://people.mozilla.org/~jorendorff/es6-draft.html#sec-json.parse"><dfn>JSON.parse</dfn></a></code>
        are defined in [[!ECMASCRIPT]].
      </p>
      <p>
        <code><a href="http://www.w3.org/TR/dom/#eventinit"><dfn>EventInit</dfn></a></code>,
        <code><a href="http://www.w3.org/TR/dom/#domexception"><dfn>DOMException</dfn></a></code>,
        <code><a href="http://www.w3.org/TR/dom/#aborterror"><dfn>AbortError</dfn></a></code>,
        <code><a href=
        "http://www.w3.org/TR/dom/#invalidstateerror"><dfn>InvalidStateError</dfn></a></code>,
        <code><a href=
        "http://www.w3.org/TR/dom/#securityerror"><dfn>SecurityError</dfn></a></code>,
        <code><a href="http://www.w3.org/TR/dom/#networkerror"><dfn>NetworkError</dfn></a></code>,
        <a href="http://www.w3.org/TR/dom/#concept-event-listener"><dfn>event listener</dfn></a>,
        and <a href="http://www.w3.org/TR/dom/#concept-event-constructor"><dfn>steps for
        constructing events</dfn></a> are defined in [[!DOM]].
      </p>
      <p>
        The terms <a href="http://www.w3.org/TR/service-workers/#dfn-service-worker"><dfn>service
        worker</dfn></a>, <a href=
        "http://www.w3.org/TR/service-workers/#dfn-service-worker-registration"><dfn>service worker
        registration</dfn></a>, <a href=
        "http://www.w3.org/TR/service-workers/#dfn-installing-worker"><dfn>installing
        worker</dfn></a>, <a href=
        "http://www.w3.org/TR/service-workers/#dfn-waiting-worker"><dfn>waiting worker</dfn></a>,
        and <a href="http://www.w3.org/TR/service-workers/#dfn-active-worker"><dfn>active
        worker</dfn></a>, and the types <code><a href=
        "http://www.w3.org/TR/service-workers/#service-worker-registration-interface"><dfn>ServiceWorkerRegistration</dfn></a></code>,
        <code><a href=
        "http://www.w3.org/TR/service-workers/#service-worker-global-scope-interface"><dfn>ServiceWorkerGlobalScope</dfn></a></code>,
        <code><a href=
        "http://www.w3.org/TR/service-workers/#extendable-event-interface"><dfn>ExtendableEvent</dfn></a></code>,
        <code><a href=
        "http://www.w3.org/TR/service-workers/#extendable-event-init-dictionary"><dfn>ExtendableEventInit</dfn></a></code>,
        <a href="http://www.w3.org/TR/service-workers/#dfn-extend-lifetime-promises"><dfn>extend
        lifetime promises</dfn></a> and the <a href=
        "http://www.w3.org/TR/service-workers/#handle-functional-event-algorithm"><dfn>Handle
        Functional Event</dfn></a> algorithm are defined in [[!SERVICE-WORKERS]].
      </p>
      <p>
        The algorithms <a href="http://www.w3.org/TR/encoding/#utf-8-encode"><dfn>utf-8
        encode</dfn></a>, and <a href="http://www.w3.org/TR/encoding/#utf-8-decode"><dfn>utf-8
        decode</dfn></a> are defined in [[!ENCODING]].
      </p>
      <p>
        <code><a href="http://www.w3.org/TR/FileAPI/#blob"><dfn>Blob</dfn></a></code> is defined in
        [[!FILEAPI]].
      </p>
      <p>
        <code><a href="http://www.w3.org/TR/WebIDL/#idl-any"><dfn>Any</dfn></a></code>,
        <code><a href=
        "http://heycam.github.io/webidl/#idl-ArrayBuffer"><dfn>ArrayBuffer</dfn></a></code>,
        <code><a href=
        "http://heycam.github.io/webidl/#common-BufferSource"><dfn>BufferSource</dfn></a></code>,
        and <code><a href=
        "http://heycam.github.io/webidl/#idl-USVString"><dfn>USVString</dfn></a></code> are defined
        in [[!WEBIDL]].
      </p>
      <p>
        The <dfn>web push protocol</dfn> [[!WEBPUSH-PROTOCOL]] describes a protocol that enables
        communication between a <a>user agent</a> or <a>application server</a> and a <a>push
        service</a>. Alternative protocols could be used in place of this protocol, but this
        specification assumes the use of this protocol; alternative protocols are expected to
        provide compatible semantics.
      </p>
    </section>
    <section>
      <h2>
        Concepts
      </h2>
      <section>
        <h2>
          Webapp
        </h2>
        <p>
          The term <dfn data-lt="webapp|webapps">webapp</dfn> refers to a Web application, i.e. an
          application implemented using Web technologies, and executing within the context of a Web
          <a>user agent</a>, e.g. a Web browser or other Web runtime environment.
        </p>
        <p>
          The term <dfn data-lt="application server|application servers">application server</dfn>
          refers to server-side components of a <a>webapp</a>.
        </p>
      </section>
      <section>
        <h2>
          Push message
        </h2>
        <p>
          A <dfn data-lt="push message|push messages">push message</dfn> is data sent to a
          <a>webapp</a> from an <a>application server</a>.
        </p>
        <p>
          A <a>push message</a> is delivered to the <a>active worker</a> associated with the
          <a>push subscription</a> to which the message was submitted. If the service worker is not
          currently running, the worker is started to enable delivery.
        </p>
      </section>
      <section>
        <h2>
          Push subscription
        </h2>
        <p>
          A <dfn data-lt="push subscription|push subscriptions">push subscription</dfn> is a
          message delivery context established between the <a>user agent</a> and the <a>push
          service</a> on behalf of a <a>webapp</a>. Each <a>push subscription</a> is associated
          with a <a>service worker registration</a> and a <a>service worker registration</a> has at
          most one <a>push subscription</a>.
        </p>
        <p>
          When a <a>push subscription</a> is <dfn data-lt=
          "deactivated|deactivate">deactivated</dfn>, both the <a>user agent</a> and the <a>push
          service</a> MUST delete any stored copies of its details. Subsequent <a>push messages</a>
          for this <a>push subscription</a> MUST NOT be delivered.
        </p>
        <p>
          A <a>push subscription</a> is <a>deactivated</a> when its associated <a>service worker
          registration</a> is unregistered, though a <a>push subscription</a> MAY be
          <a>deactivated</a> earlier.
        </p>
        <p>
          A <a>push subscription</a> has an associated <dfn data-lt=
          "endpoint|endpoints">endpoint</dfn>. It MUST be the absolute URL exposed by the <a>push
          service</a> where the <a>application server</a> can send <a>push messages</a> to. An
          <a>endpoint</a> MUST uniquely identify the <a>push subscription</a>.
        </p>
      </section>
      <section>
        <h2>
          Push service
        </h2>
        <p>
          The term <dfn data-lt="push service|push services">push service</dfn> refers to a system
          that allows <a>application servers</a> to send <a>push messages</a> to a <a>webapp</a>. A
          push service serves the <a>endpoint</a> or <a>endpoints</a> for the <a>push
          subscriptions</a> it serves.
        </p>
      </section>
      <section>
        <h2>
          Permission
        </h2>
        <p>
          The term <dfn>express permission</dfn> refers to an act by the user, e.g. via user
          interface or host device platform features, via which the user approves the use of the
          push API by the <a>webapp</a>.
        </p>
      </section>
    </section>
    <section>
      <h2>
        Security and privacy considerations
      </h2>
      <p>
        <a>User agents</a> MUST NOT provide Push API access to <a>webapps</a> without the
        <a>express permission</a> of the user. <a>User agents</a> MUST acquire consent for
        permission through a user interface for each call to the <code>subscribe()</code> method,
        unless a previous permission grant has been persisted, or a prearranged trust relationship
        applies. Permissions that are preserved beyond the current browsing session MUST be
        revocable.
      </p>
      <p>
        The <a>user agent</a> MAY consider the <code><a>PushSubscriptionOptions</a></code> when
        acquiring permission or determining the permission status.
      </p>
      <p>
        When a permission is revoked, all <a>push subscriptions</a> created with that permission
        MUST be <a>deactivated</a>.
      </p>
      <p>
        When a <a>service worker registration</a> is unregistered, any associated <a>push
        subscription</a> MUST be <a>deactivated</a>.
      </p>
      <p>
        The <a>endpoint</a> of a <a>deactivated</a> <a>push subscription</a> MUST NOT be reused for
        a new <a>push subscription</a>. This prevents the creation of a persistent identifier that
        the user cannot remove. This also prevents reuse of the details of one <a>push
        subscription</a> to send <a>push messages</a> to another <a>push subscription</a>.
      </p>
      <p>
        <a>User agents</a> MUST implement the Push API to be HTTPS-only. SSL-only support provides
        better protection for the user against man-in-the-middle attacks intended to obtain push
        subscription data. Browsers may ignore this rule for development purposes only.
      </p>
    </section>
    <section class='informative' id="pushframework">
      <h2>
        Push Framework
      </h2>
      <p>
        A <a>push message</a> is sent from an <a>application server</a> to a <a>webapp</a> as
        follows:
      </p>
      <ul>
        <li>the <a>application server</a> requests that the <a>push service</a> deliver a <a>push
        message</a> using the [[!WEBPUSH-PROTOCOL]]. This request uses the <a>endpoint</a> included
        in the <a>push subscription</a>;
        </li>
        <li>the <a>push service</a> delivers the message to a specific <a>user agent</a>,
        identifying the <a>endpoint</a> in the message;
        </li>
        <li>the <a>user agent</a> identifies the intended <a>Service Worker</a> and activates it as
        necessary, and delivers the <a>push message</a> to the <a>Service Worker</a>.
        </li>
      </ul>
      <p>
        This overall framework allows <a>application servers</a> to activate a <a>Service
        Worker</a> in response to events at the <a>application server</a>. Information about those
        events can be included in the <a>push message</a>, which allows the <a>webapp</a> to react
        appropriately to those events, potentially without needing to initiate network requests.
      </p>
      <p>
        The following code and diagram illustrate a hypothetical use of the push API.
      </p>
      <section class="informative">
        <h2>
          Example
        </h2>
        <pre class="example highlight">// https://example.com/serviceworker.js
this.onpush = function(event) {
  console.log(event.data);
  // From here we can write the data to IndexedDB, send it to any open
  // windows, display a notification, etc.
}

// https://example.com/webapp.js
navigator.serviceWorker.register('serviceworker.js').then(
  function(serviceWorkerRegistration) {
    serviceWorkerRegistration.pushManager.subscribe().then(
      function(pushSubscription) {
        console.log(pushSubscription.endpoint);
        console.log(pushSubscription.getKey('p256dh'));
        // The push subscription details needed by the application
        // server are now available, and can be sent to it using,
        // for example, an XMLHttpRequest.
      }, function(error) {
        // During development it often helps to log errors to the
        // console. In a production environment it might make sense to
        // also report information about errors back to the
        // application server.
        console.log(error);
      }
    );
  });
</pre>
      </section>
      <section class="informative">
        <h2>
          Sequence diagram
        </h2>
        <figure>
          <a href="sequence_diagram.png"><img src="sequence_diagram.png" width="795" height="870"
          alt=
          "Example flow of events for subscription, push message delivery, and unsubscription"></a>
          <figcaption>
            Example flow of events for subscription, push message delivery, and unsubscription
          </figcaption>
        </figure>
      </section>
      <section>
        <h3>
          Push service use
        </h3>
        <p>
          The fields included in the <code>PushSubscription</code> is all the information needed
          for an <a>application server</a> to send a <a>push message</a>. Push services that are
          compatible with the Push API provide an <a>endpoint</a> that conforms to the <a>web push
          protocol</a>. These parameters and attributes include:
        </p>
        <ul>
          <li>The <code><a data-lt="PushSubscription-endpoint">endpoint</a></code> of a
          <code>PushSubscription</code> is a URL that allows an <a>application server</a> to
          request delivery of a <a>push message</a> to a <a>webapp</a>.
          </li>
          <li>The <code><a data-lt="PushSubscription-getKey">getKey</a></code> method on a
          <code>PushSubscription</code> is used to retrieve keying material used to encipher
          <a>push messages</a>. Each invocation of the function returns a new
          <code>ArrayBuffer</code> that contains the value of the corresponding key, or
          <code>null</code> if the identified key doesn't exist. Passing a value of
          <code>p256dh</code> retrieves a <dfn data-lt="ECDH">elliptic curve Diffie-Hellman
          (ECDH)</dfn> public key associated with the <a>push subscription</a>. This key is used by
          the <a>application server</a> to encipher messages for the <a>push subscription</a>, as
          described in [[!WEBPUSH-ENCRYPTION]].
          </li>
        </ul>
      </section>
    </section>
    <section>
      <h2>
        Extensions to the <a>ServiceWorkerRegistration</a> interface
      </h2>
      <p>
        The Service Worker specification defines a <code>ServiceWorkerRegistration</code> interface
        [[!SERVICE-WORKERS]], which this specification extends.
      </p>
      <dl title="partial interface ServiceWorkerRegistration" class="idl">
        <dt>
          readonly attribute PushManager pushManager
        </dt>
      </dl>
      <p>
        The <code><dfn id="widl-ServiceWorkerRegistration-pushManager">pushManager</dfn></code>
        attribute exposes a <code><a>PushManager</a></code>, which has an associated <a>service
        worker registration</a> represented by the <code><a>ServiceWorkerRegistration</a></code> on
        which the attribute is exposed.
      </p>
    </section>
    <section>
      <h2>
        <a>PushManager</a> interface
      </h2>
      <p>
        The <a>PushManager</a> interface defines the operations to access <a>push services</a>.
      </p>
      <dl title="interface PushManager" class="idl">
        <dt>
          Promise&lt;PushSubscription&gt; subscribe (optional PushSubscriptionOptions options)
        </dt>
        <dt>
          Promise&lt;PushSubscription?&gt; getSubscription ()
        </dt>
        <dt>
          Promise&lt;PushPermissionState&gt; permissionState (optional PushSubscriptionOptions
          options)
        </dt>
      </dl>
      <p>
        The <code><dfn id=
        "widl-PushManager-subscribe-Promise-PushSubscription--PushSubscriptionOptions-options">subscribe</dfn></code>
        method when invoked MUST run the following steps:
      </p>
      <ol>
        <li>Let <var>promise</var> be a new <a><code>Promise</code></a>.
        </li>
        <li>Return <var>promise</var> and continue the following steps asynchronously.
        </li>
        <li>If the scheme of the document url is not <code>https</code>, reject <var>promise</var>
        with a <code><a>DOMException</a></code> whose name is "<code><a>SecurityError</a></code>"
        and terminate these steps.
        </li>
        <li>Let <var>registration</var> be the <code><a>PushManager</a></code>'s associated
        <a>service worker registration</a>.
        </li>
        <li>If <var>registration</var> has no <a>active worker</a>, run the following substeps:
          <ol>
            <li>If <var>registration</var> has no <a>installing worker</a> and no <a>waiting
            worker</a>, reject <var>promise</var> with a <code><a>DOMException</a></code> whose
            name is "<code><a>InvalidStateError</a></code>" and terminate these steps.
            </li>
            <li>Wait for the <a>installing worker</a> or <a>waiting worker</a> of
            <var>registration</var> to become its <a>active worker</a>.
            </li>
            <li>If <var>registration</var> fails to activate either worker, reject
            <var>promise</var> with a <code><a>DOMException</a></code> whose name is
            "<code><a>InvalidStateError</a></code>" and terminate these steps.
            </li>
            <li>Once <var>registration</var> has an <a>active worker</a>, proceed with the steps
            below.
            </li>
          </ol>
        </li>
        <li>Ask the user whether they allow the <a>webapp</a> to receive <a>push messages</a>,
        unless a prearranged trust relationship applies or the user has already granted or denied
        permission explicitly for this <a>webapp</a>.
        </li>
        <li>If not granted, reject <var>promise</var> with a <code><a>DOMException</a></code> whose
        name is "<code><a>PermissionDeniedError</a></code>" and terminate these steps.
        </li>
        <li>If the <a>Service Worker</a> is already subscribed, run the following substeps:
          <ol>
            <li>Retrieve the <a>push subscription</a> associated with the <a>Service Worker</a>.
            </li>
            <li>If there is an error, reject <var>promise</var> with a
            <code><a>DOMException</a></code> whose name is "<code><a>AbortError</a></code>" and
            terminate these steps.
            </li>
            <li>When the request has been completed, resolve <var>promise</var> with a
            <a><code>PushSubscription</code></a> providing the details of the retrieved <a>push
            subscription</a>.
            </li>
          </ol>
        </li>
        <li>Make a request to the push service to create a new <a>push subscription</a> for the <a>
          Service Worker</a>.
        </li>
        <li>If there is an error, reject <var>promise</var> with a <code><a>DOMException</a></code>
        whose name is "<code><a>AbortError</a></code>" and terminate these steps.
        </li>
        <li>Generate a new P-256 <a>ECDH</a> key pair. Store the private key in an internal slot
        associated with the subscription; this value MUST NOT be made available to applications.
        The public key is also stored in an internal slot and can be retrieved by calling the
        <code>getKey</code> of the <a><code>PushSubscription</code></a> with an argument of <code>
          p256dh</code>.
        </li>
        <li>When the request has been completed, resolve <var>promise</var> with a
        <a><code>PushSubscription</code></a> providing the details of the new <a>push
        subscription</a>.
        </li>
      </ol>
      <p>
        The <code><dfn id=
        "widl-PushManager-getSubscription-Promise-PushSubscription">getSubscription</dfn></code>
        method when invoked MUST run the following steps:
      </p>
      <ol>
        <li>Let <var>promise</var> be a new <a><code>Promise</code></a>.
        </li>
        <li>Return <var>promise</var> and continue the following steps asynchronously.
        </li>
        <li>If the <a>Service Worker</a> is not subscribed, resolve <var>promise</var> with null.
        </li>
        <li>Retrieve the <a>push subscription</a> associated with the <a>Service Worker</a>.
        </li>
        <li>If there is an error, reject <var>promise</var> with a <code><a>DOMException</a></code>
        whose name is "<code><a>AbortError</a></code>" and terminate these steps.
        </li>
        <li>When the request has been completed, resolve <var>promise</var> with a
        <a><code>PushSubscription</code></a> providing the details of the retrieved <a>push
        subscription</a>.
        </li>
      </ol>
      <p>
        The <code><dfn id=
        "widl-PushManager-permissionState-Promise-PushPermissionState--PushSubscriptionOptions-options">
        permissionState</dfn></code> method when invoked MUST run the following steps:
      </p>
      <ol>
        <li>Let <var>promise</var> be a new <a><code>Promise</code></a>.
        </li>
        <li>Return <var>promise</var> and continue the following steps asynchronously.
        </li>
        <li>Retrieve the push permission status (<a><code>PushPermissionState</code></a>) of the
        requesting <a>webapp</a>.
        </li>
        <li>If there is an error, reject <var>promise</var> with no arguments and terminate these
        steps.
        </li>
        <li>When the request has been completed, resolve <var>promise</var> with
        <a><code>PushPermissionState</code></a> providing the push permission status.
        </li>
      </ol>
      <p>
        Permission to use the push service can be persistent, that is, it does not need to be
        reconfirmed for subsequent subscriptions if a valid permission exists.
      </p>
      <p>
        If there is a need to ask for permission, it needs to be done by invoking the
        <a><code>subscribe</code></a> method.
      </p>
      <section>
        <h2>
          <a>PushSubscriptionOptions</a> dictionary
        </h2>
        <p>
          A <a>PushSubscriptionOptions</a> object represents additional options associated with a
          <a>push subscription</a>. The <a>user agent</a> MAY consider these options when
          requesting <a>express permission</a> from the user. When an option is considered, the
          <a>user agent</a> SHOULD enforce it on incoming <a>push messages</a>.
        </p>
        <dl title="dictionary PushSubscriptionOptions" class="idl">
          <dt>
            boolean userVisibleOnly = false
          </dt>
        </dl>
        <p>
          The <code><dfn id=
          "widl-PushSubscriptionOptions-userVisibleOnly">userVisibleOnly</dfn></code> option, when
          set to <code>true</code>, indicates that the <a>push subscription</a> will only be used
          for <a>push messages</a> whose effect is made visible to the user, for example by
          displaying a Web Notification. [[NOTIFICATIONS]]
        </p>
      </section>
    </section>
    <section>
      <h2>
        <a>PushSubscription</a> interface
      </h2>
      <p>
        A <a>PushSubscription</a> object represents a <a>push subscription</a>.
      </p>
      <dl title="interface PushSubscription" class="idl">
        <dt>
          readonly attribute USVString endpoint
        </dt>
        <dt>
          ArrayBuffer? getKey (PushEncryptionKeyName name)
        </dt>
        <dt>
          Promise&lt;boolean&gt; unsubscribe ()
        </dt>
        <dt>
          serializer
        </dt>
      </dl>
      <p>
        When getting the <code><dfn id="widl-PushSubscription-endpoint" data-lt=
        "PushSubscription-endpoint">PushSubscription.endpoint</dfn></code> attribute, the <a>user
        agent</a> MUST return the <a>endpoint</a> associated with the <a>push subscription</a>.
      </p>
      <p>
        The <code><dfn id="widl-PushSubscription-getKey-ArrayBuffer-PushEncryptionKeyName-name"
        data-lt="PushSubscription-getKey|getKey">PushSubscription.getKey</dfn></code> method
        retrieves a public key that can be used for enciphering messages. When <code><a data-lt=
        "PushSubscription-getKey">getKey</a></code> is invoked the following process is followed:
      </p>
      <ol>
        <li>Find the internal slot that contains the encryption key pair named by the
        <code>name</code> argument.
        </li>
        <li>If an encryption key was not found, return <code>null</code>.
        </li>
        <li>Initialize a variable <var>key</var> with a newly instantiated <code>ArrayBuffer</code>
        instance.
        </li>
        <li>Set the contents of <var>key</var> to the serialized value of the public key from the
        key pair. This uses the serialization format described in the specification that defines
        the name. For example, [[!WEBPUSH-ENCRYPTION]] specifies that the <code>p256dh</code>
        public key is encoded using the uncompressed format defined in [[X9.62]] Annex A (that is,
        a 65 octet sequence that starts with a 0x04 octet).
        </li>
        <li>Return <var>key</var>.
        </li>
      </ol>
      <p>
        An encryption key named <code>p256dh</code> MUST be supported, which is used to retrieve a
        P-256 ECDH public key as described by [[!WEBPUSH-ENCRYPTION]].
      </p>
      <p>
        The <code><dfn id=
        "widl-PushSubscription-unsubscribe-Promise-boolean">unsubscribe</dfn></code> method when
        invoked MUST run the following steps:
      </p>
      <ol>
        <li>Let <var>promise</var> be a new <a><code>Promise</code></a>.
        </li>
        <li>Return <var>promise</var> and continue the following steps asynchronously.
        </li>
        <li>If the <a>push subscription</a> has already been <a>deactivated</a>, resolve
        <var>promise</var> with <code>false</code> and terminate these steps.
        </li>
        <li>Make a request to the <a>push service</a> to <a>deactivate</a> the <a>push
        subscription</a>.
        </li>
        <li>If it was not possible to access the <a>push service</a>, reject <var>promise</var>
        with a "<code><a>NetworkError</a></code>" exception and terminate these steps.
        </li>
        <li>When the request has been completed, resolve <var>promise</var> with <code>true</code>.
        </li>
      </ol>
      <p>
        The serializer for a <a><code>PushSubscription</code></a> invokes the following steps:
      </p>
      <ol>
        <li>Let <var>map</var> be an empty map.
        </li>
        <li>Add an entry to <var>map</var> whose key name is <code>endpoint</code> and whose value
        is the result of converting the <code>endpoint</code> attribute of the
        <a><code>PushSubscription</code></a> to a serialized value. The <a>user agent</a> MUST use
        a serialization method that does not contain input-dependent branchs (that is, one that is
        constant time). Note that a URL - as ASCII text - will not ordinarily require special
        treatment.
        </li>
        <li>Let <var>keys</var> be an empty map.
        </li>
        <li>For each identifier <var>i</var> corresponding to keys in internal slots on the
        <a><code>PushSubscription</code></a>, ordered by the name of the key:
          <ol>
            <li>Let <var>b</var> by the encoded value of the public key corresponding to the key
            name <var>i</var>, using the encoding defined for the key name (see <code><a data-lt=
            "PushSubscription.getKey">getKey</a></code>).
            </li>
            <li>Let <var>s</var> be the URL-safe base64 encoding of <var>b</var> as a
            <code><a>USVString</a></code>. The <a>user agent</a> MUST use a serialization method
            that does not branch based on the value of <var>b</var>.
            </li>
            <li>Add an entry to <var>keys</var> whose key name is the name of <var>i</var> and
            whose value is <var>s</var>.
            </li>
          </ol>
        </li>
        <li>Add an entry to <var>map</var> whose key name is <code>keys</code> and whose value is
        <var>keys</var>.
        </li>
        <li>Return <var>map</var>.
        </li>
      </ol>
      <section>
        <h2>
          <a>PushEncryptionKeyName</a> enumeration
        </h2>
        <p>
          Encryption keys used for <a>push message</a> encryption are provided to a <a>webapp</a>
          through the <code>getKey</code> method or the serializer of
          <code><a>PushSubscription</a></code>. Each key is named using a value from the
          <code><dfn>PushEncryptionKeyName</dfn></code> enumeration.
        </p>
        <dl title="enum PushEncryptionKeyName" class="idl">
          <dt>
            p256dh
          </dt>
        </dl>
        <p>
          The <code><dfn id="widl-PushEncryptionKeyName-p256dh">p256dh</dfn></code> value is used
          to retrieve the P-256 ECDH Diffie-Hellman public key described in
          [[!WEBPUSH-ENCRYPTION]].
        </p>
      </section>
    </section>
    <section>
      <h2>
        <a>PushMessageData</a> interface
      </h2>
      <dl title="interface PushMessageData" class="idl" data-merge="JSON">
        <dt>
          ArrayBuffer arrayBuffer ()
        </dt>
        <dt>
          Blob blob ()
        </dt>
        <dt>
          JSON json ()
        </dt>
        <dt>
          USVString text ()
        </dt>
      </dl>
      <dl title="typedef object JSON" class="idl"></dl>
      <p>
        <a>PushMessageData</a> objects have an associated <dfn>bytes</dfn> (a byte sequence) set on
        creation.
      </p>
      <p>
        The <code><dfn id="widl-PushMessageData-arrayBuffer-ArrayBuffer">arrayBuffer()</dfn></code>
        method, when invoked, MUST return an <a><code>ArrayBuffer</code></a> whose contents are
        <var>bytes</var>. Exceptions thrown during the creation of the
        <a><code>ArrayBuffer</code></a> object are re-thrown.
      </p>
      <p>
        The <code><dfn id="widl-PushMessageData-blob-Blob">blob()</dfn></code> method, when
        invoked, MUST return a <a><code>Blob</code></a> whose contents are <var>bytes</var> and
        <var>type</var> is not provided.
      </p>
      <p>
        The <code><dfn id="widl-PushMessageData-json-JSON">json()</dfn></code> method, when
        invoked, MUST return the result of invoking the initial value of
        <a><code>JSON.parse</code></a> with the result of running <a>utf-8 decode</a> on
        <var>bytes</var> as argument. Re-throw any exceptions thrown by
        <a><code>JSON.parse</code></a>.
      </p>
      <p>
        The <code><dfn id="widl-PushMessageData-text-USVString">text()</dfn></code> method, when
        invoked, MUST return the result of running <a>utf-8 decode</a> on <var>bytes</var>.
      </p>
      <div class="idl" title="typedef (BufferSource or USVString) PushMessageDataInit"></div>
      <p>
        To <dfn>extract a byte sequence</dfn> from <var>object</var>, run these steps:
      </p>
      <ol>
        <li>Let <var>bytes</var> be an empty byte sequence.
        </li>
        <li>Switch on <var>object</var>'s type:
          <dl>
            <dt>
              <a><code>BufferSource</code></a>
            </dt>
            <dd>
              Set <var>bytes</var> to a copy of <var>object</var>'s contents.
            </dd>
            <dt>
              <a><code>USVString</code></a>
            </dt>
            <dd>
              Set <var>bytes</var> to the result of running <a>utf-8 encode</a> on
              <var>object</var>.
            </dd>
          </dl>
        </li>
        <li>Return <var>bytes</var>.
        </li>
      </ol>
    </section>
    <section>
      <h2>
        Events
      </h2>
      <p>
        The Service Worker specification defines a <code>ServiceWorkerGlobalScope</code> interface
        [[!SERVICE-WORKERS]], which this specification extends.
      </p>
      <dl title="partial interface ServiceWorkerGlobalScope" class="idl">
        <dt>
          attribute EventHandler onpush
        </dt>
        <dt>
          attribute EventHandler onpushsubscriptionchange
        </dt>
      </dl>
      <p>
        The <code><dfn id="widl-ServiceWorkerGlobalScope-onpush">onpush</dfn></code> attribute is
        an <a>event handler</a> whose corresponding <a>event handler event type</a> is
        <code>push</code>.
      </p>
      <p>
        The <code><dfn id=
        "widl-ServiceWorkerGlobalScope-onpushsubscriptionchange">onpushsubscriptionchange</dfn></code>
        attribute is an <a>event handler</a> whose corresponding <a>event handler event type</a> is
        <code>pushsubscriptionchange</code>.
      </p>
      <section>
        <h2>
          The <code>push</code> event
        </h2>
        <p>
          The <a>PushEvent</a> interface represents a received <a>push message</a>.
        </p>
        <dl title=
        "[Constructor(DOMString type, optional PushEventInit eventInitDict), Exposed=ServiceWorker] interface PushEvent : ExtendableEvent"
        class="idl" data-merge="PushEventInit">
          <dt>
            readonly attribute PushMessageData data
          </dt>
        </dl>
        <dl title="dictionary PushEventInit : ExtendableEventInit" class="idl">
          <dt>
            PushMessageDataInit data
          </dt>
        </dl>
        <p>
          Upon receiving a <a>push message</a> for a <a>push subscription</a> from the <a>push
          service</a> the <a>user agent</a> MUST run the following steps:
        </p>
        <ol>
          <li>Identify the <a>Service Worker</a> for the <a>push subscription</a>.
          </li>
          <li>If the <a>Service Worker</a> is not running, start it.
          </li>
          <li>Let <var>scope</var> be the <code>ServiceWorkerGlobalScope</code> of the <a>Service
          Worker</a>.
          </li>
          <li>Let <var>subscription</var> be the active <a>push subscription</a> for the <a>Service
          Worker</a>.
          </li>
          <li>Decrypt the <a>push message</a> using the private key from the key pair associated
          with <var>subscription</var> and the process described in [[!WEBPUSH-ENCRYPTION]]. This
          produces the plain text of the message.
          </li>
          <li>If the <a>push message</a> could not be decrypted for any reason, or if it is not
          encrypted and contains any payload, discard the message and terminate this process. A
          push message MAY be empty if it contains no content, but otherwise <code>push</code>
          event MUST NOT be fired for a <a>push message</a> that was not successfully decrypted
          using the key pair associated with the <a>push subscription</a>.
          </li>
          <li>Let <var>pushdata</var> be the decrypted plain text of the <a>push message</a>.
          </li>
          <li>Let <var>event</var> be a new <a>PushEvent</a>, whose <code id="widl-PushEvent-data">
            data</code> attribute is a new <a>PushMessageData</a> with <a>bytes</a> set to the
            value of <var>pushdata</var>.
          </li>
          <li>
            <a>Queue a task</a> to <a data-lt="fire a simple event">fire <var>event</var> as a
            simple event</a> named <code>push</code> at <var>scope</var>.
          </li>
        </ol>
        <p>
          When a constructor of the <a>PushEvent</a> interface, or of an interface that inherits
          from the <a>PushEvent</a> interface, is invoked, the usual <a>steps for constructing
          events</a> MUST be modified as follows: instead of setting the <code>data</code>
          attribute of the event to the value of the <var>eventInitDict</var>'s "<code id=
          "widl-PushEventInit-data">data</code>" member, set the <code>data</code> attribute to a
          new <a>PushMessageData</a> with <a>bytes</a> set to the result of <a data-lt=
          "extract a byte sequence">extracting a byte sequence</a> from that dictionary member, or
          an empty byte sequence if the "<code id="widl-PushEventInit-data">data</code>" member is
          not provided.
        </p>
      </section>
      <section>
        <h2>
          The <code>pushsubscriptionchange</code> event
        </h2>
        <p>
          The <code>pushsubscriptionchange</code> event indicates that a <a>push subscription</a>
          has been invalidated, or will soon be invalidated. For example, the <a>push service</a>
          MAY set an expiration time. A <a>Service Worker</a> SHOULD attempt to resubscribe while
          handling this event, in order to continue receiving <a>push messages</a>.
        </p>
        <p>
          When new <a>push subscription</a> information becomes available, the <a>user agent</a>
          MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>registration</var> be the <a>service worker registration</a> corresponding
          to the push message.
          </li>
          <li>If <var>registration</var> is not found, abort these steps.
          </li>
          <li>Invoke the <a>Handle Functional Event</a> algorithm with a <a>service worker
          registration</a> of <var>registration</var> and <var>callbackSteps</var> set to the
          following steps:
            <ol>
              <li>Set <var>global</var> to the global object that was provided as an argument.
              </li>
              <li>Create a <a>trusted event</a>, <var>e</var>, that uses the
              <code><a>ExtendableEvent</a></code> interface, with the event type
              <code>pushsubscriptionchange</code>, which does not bubble, is not cancelable, and
              has no default action.
              </li>
              <li>Dispatch <var>e</var> to <var>global</var>.
              </li>
              <li>If the previous <a>push subscription</a> is still active, perform the following
              steps in parallel:
                <ol>
                  <li>Set <var>oldSubscription</var> to the previous <a>push subscription</a>.
                  </li>
                  <li>Wait for all of the promises in the <a>extend lifetime promises</a> of <var>
                    e</var> to either resolve or reject.
                  </li>
                  <li>Unsubscribe <var>oldSubscription</var>.
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
        <p>
          This algorithm ensures that the <a>Service Worker</a> is able to react to any
          non-destructive change in a <a>push subscription</a>, such as an automatic refresh,
          without causing any active <a>push subscription</a> to be terminated prematurely. A
          <a>Service Worker</a> can request a new <a>push subscription</a> during this process and
          ensure that no <a>push messages</a> are lost.
        </p>
      </section>
    </section>
    <section>
      <h2>
        Enumerations
      </h2>
      <dl class="idl" title="enum PushPermissionState">
        <dt>
          granted
        </dt>
        <dt>
          denied
        </dt>
        <dt>
          prompt
        </dt>
      </dl>
      <table class="simple">
        <tr>
          <th>
            Enumeration
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            <code id="idl-def-PushPermissionState.granted">granted</code>
          </td>
          <td>
            The <a>webapp</a> has permission to use the Push API.
          </td>
        </tr>
        <tr>
          <td>
            <code id="idl-def-PushPermissionState.denied">denied</code>
          </td>
          <td>
            The <a>webapp</a> has been denied permission to use the Push API.
          </td>
        </tr>
        <tr>
          <td>
            <code id="idl-def-PushPermissionState.prompt">prompt</code>
          </td>
          <td>
            The <a>webapp</a> needs to ask for permission in order to use the Push API.
          </td>
        </tr>
      </table>
    </section>
    <section>
      <h2>
        Exceptions
      </h2>
      <p>
        The Push API uses the following new <a>DOMException</a> names.
      </p>
      <table class="simple">
        <tr>
          <th>
            Name
          </th>
          <th>
            Description
          </th>
        </tr>
        <tr>
          <td>
            <code><dfn>PermissionDeniedError</dfn></code>
          </td>
          <td>
            The operation failed because the user denied permission to use the API.
          </td>
        </tr>
      </table>
    </section>
    <section class="appendix">
      <h2>
        Acknowledgements
      </h2>
      <p>
        The editors would like to express their gratitude to the Mozilla and Telefónica Digital
        teams implementing the Firefox OS Push message solution and specially to Doug Turner,
        Nikhil Marathe, Fernando R. Sela, Guillermo López, Antonio Amaya, José Manuel Cantera and
        Albert Crespell, for their technical guidance, implementation work and support.
      </p>
    </section>
  </body>
</html>
